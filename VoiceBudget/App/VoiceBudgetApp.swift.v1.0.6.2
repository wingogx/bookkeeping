import SwiftUI
import Speech
import AVFoundation
import UserNotifications

// MARK: - App Entry Point
@main
struct VoiceBudgetApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(DataManager.shared)
        }
    }
}

// MARK: - Data Models
struct Transaction: Identifiable, Codable {
    let id: UUID
    let amount: Double
    let category: String
    let note: String
    let date: Date
    let isExpense: Bool

    init(amount: Double, category: String, note: String, date: Date, isExpense: Bool) {
        self.id = UUID()
        self.amount = amount
        self.category = category
        self.note = note
        self.date = date
        self.isExpense = isExpense
    }
}

// MARK: - Achievement System
struct Achievement: Identifiable, Codable {
    let id: UUID
    let name: String
    let description: String
    let icon: String
    let isUnlocked: Bool
    let unlockedAt: Date?
    let type: AchievementType

    enum AchievementType: String, Codable {
        case firstRecord = "first_record"
        case streak3 = "streak_3"
        case streak7 = "streak_7"
        case streak15 = "streak_15"
        case streak30 = "streak_30"
        case budgetSaver = "budget_saver"
        case budgetMaster = "budget_master"
        case budgetControl = "budget_control"
    }

    init(name: String, description: String, icon: String, type: AchievementType, isUnlocked: Bool = false, unlockedAt: Date? = nil) {
        self.id = UUID()
        self.name = name
        self.description = description
        self.icon = icon
        self.type = type
        self.isUnlocked = isUnlocked
        self.unlockedAt = unlockedAt
    }
}

// MARK: - User Stats
struct UserStats: Codable {
    var totalTransactions: Int = 0
    var currentStreak: Int = 0
    var maxStreak: Int = 0
    var lastRecordDate: Date?
    var totalSaved: Double = 0
    var monthsWithoutOverspend: Int = 0

    init() {}
}

// MARK: - App Settings
struct AppSettings: Codable {
    var notificationsEnabled: Bool = false
    var morningReminderEnabled: Bool = true
    var afternoonReminderEnabled: Bool = true
    var eveningReminderEnabled: Bool = true
    var morningReminderTime: String = "10:00"
    var afternoonReminderTime: String = "15:00"
    var eveningReminderTime: String = "21:00"
    var budgetWarningEnabled: Bool = true
    var weeklyReportEnabled: Bool = true

    static let `default` = AppSettings()
}

// MARK: - Export Data Models
struct ExportData {
    enum DateRange: String, CaseIterable {
        case allTime = "all_time"
        case lastMonth = "last_month"
        case lastThreeMonths = "last_three_months"
        case thisYear = "this_year"
        case thisMonth = "this_month"

        var displayName: String {
            switch self {
            case .allTime: return "å…¨éƒ¨æ—¶é—´"
            case .lastMonth: return "æœ€è¿‘ä¸€ä¸ªæœˆ"
            case .lastThreeMonths: return "æœ€è¿‘ä¸‰ä¸ªæœˆ"
            case .thisYear: return "æœ¬å¹´åº¦"
            case .thisMonth: return "æœ¬æœˆ"
            }
        }
    }

    enum ExportFormat: String, CaseIterable {
        case csv = "csv"
        case txt = "txt"

        var displayName: String {
            switch self {
            case .csv: return "CSVæ ¼å¼"
            case .txt: return "æ–‡æœ¬æ ¼å¼"
            }
        }

        var fileExtension: String {
            return rawValue
        }
    }
}

struct Budget: Codable {
    var monthlyLimit: Double
    var categoryLimits: [String: Double]
    
    static let `default` = Budget(
        monthlyLimit: 3000,
        categoryLimits: [
            "é¤é¥®": 1000,
            "äº¤é€š": 500,
            "è´­ç‰©": 800,
            "å¨±ä¹": 400,
            "å…¶ä»–": 300
        ]
    )
}

// MARK: - Data Manager
class DataManager: ObservableObject {
    static let shared = DataManager()
    
    @Published var transactions: [Transaction] = []
    @Published var budget = Budget.default
    @Published var categories: [String] = ["é¤é¥®", "äº¤é€š", "è´­ç‰©", "å¨±ä¹", "ç”Ÿæ´»", "åŒ»ç–—", "æ•™è‚²", "å…¶ä»–"]
    @Published var achievements: [Achievement] = []
    @Published var userStats = UserStats()
    @Published var showAchievementAlert = false
    @Published var newAchievement: Achievement?
    @Published var appSettings = AppSettings.default

    private let transactionsKey = "transactions"
    private let budgetKey = "budget"
    private let categoriesKey = "categories"
    private let achievementsKey = "achievements"
    private let userStatsKey = "userStats"
    private let appSettingsKey = "appSettings"
    
    init() {
        loadData()
        initializeAchievements()
    }
    
    // æ·»åŠ äº¤æ˜“
    func addTransaction(_ transaction: Transaction) {
        transactions.append(transaction)
        updateUserStats()
        checkAchievements()
        checkBudgetWarnings(for: transaction)
        saveData()
    }
    
    // åˆ é™¤äº¤æ˜“
    func deleteTransaction(_ transaction: Transaction) {
        transactions.removeAll { $0.id == transaction.id }
        saveData()
    }
    
    // è·å–ä»Šæ—¥äº¤æ˜“
    var todayTransactions: [Transaction] {
        let calendar = Calendar.current
        let today = calendar.startOfDay(for: Date())
        return transactions.filter {
            calendar.startOfDay(for: $0.date) == today
        }
    }
    
    // è·å–æœ¬æœˆæ”¯å‡º
    var monthlyExpense: Double {
        let calendar = Calendar.current
        let now = Date()
        let month = calendar.component(.month, from: now)
        let year = calendar.component(.year, from: now)
        
        return transactions
            .filter { transaction in
                let tMonth = calendar.component(.month, from: transaction.date)
                let tYear = calendar.component(.year, from: transaction.date)
                return tMonth == month && tYear == year && transaction.isExpense
            }
            .reduce(0) { $0 + $1.amount }
    }
    
    // è·å–åˆ†ç±»æ”¯å‡º
    func getCategoryExpense(category: String) -> Double {
        let calendar = Calendar.current
        let now = Date()
        let month = calendar.component(.month, from: now)
        let year = calendar.component(.year, from: now)
        
        return transactions
            .filter { transaction in
                let tMonth = calendar.component(.month, from: transaction.date)
                let tYear = calendar.component(.year, from: transaction.date)
                return tMonth == month && tYear == year && 
                       transaction.isExpense && 
                       transaction.category == category
            }
            .reduce(0) { $0 + $1.amount }
    }
    
    // åˆ†ç±»ç®¡ç†æ–¹æ³•
    func addCategory(_ category: String) {
        if !categories.contains(category) && !category.isEmpty {
            categories.append(category)
            saveData()
        }
    }
    
    func deleteCategory(_ category: String) {
        // æ£€æŸ¥æ˜¯å¦æœ‰äº¤æ˜“ä½¿ç”¨æ­¤åˆ†ç±»
        let hasTransactions = transactions.contains { $0.category == category }
        if !hasTransactions {
            categories.removeAll { $0 == category }
            // ä»é¢„ç®—ä¸­ç§»é™¤æ­¤åˆ†ç±»
            budget.categoryLimits.removeValue(forKey: category)
            saveData()
        }
    }
    
    func updateCategory(oldName: String, newName: String) {
        if let index = categories.firstIndex(of: oldName) {
            categories[index] = newName
            
            // æ›´æ–°æ‰€æœ‰ä½¿ç”¨æ­¤åˆ†ç±»çš„äº¤æ˜“
            for i in transactions.indices {
                if transactions[i].category == oldName {
                    let updatedTransaction = Transaction(
                        amount: transactions[i].amount,
                        category: newName,
                        note: transactions[i].note,
                        date: transactions[i].date,
                        isExpense: transactions[i].isExpense
                    )
                    transactions[i] = updatedTransaction
                }
            }
            
            // æ›´æ–°é¢„ç®—è®¾ç½®
            if let limit = budget.categoryLimits[oldName] {
                budget.categoryLimits[newName] = limit
                budget.categoryLimits.removeValue(forKey: oldName)
            }
            
            saveData()
        }
    }
    
    // ä¿å­˜æ•°æ®
    func saveData() {
        if let encoded = try? JSONEncoder().encode(transactions) {
            UserDefaults.standard.set(encoded, forKey: transactionsKey)
        }
        if let encoded = try? JSONEncoder().encode(budget) {
            UserDefaults.standard.set(encoded, forKey: budgetKey)
        }
        if let encoded = try? JSONEncoder().encode(categories) {
            UserDefaults.standard.set(encoded, forKey: categoriesKey)
        }
        if let encoded = try? JSONEncoder().encode(achievements) {
            UserDefaults.standard.set(encoded, forKey: achievementsKey)
        }
        if let encoded = try? JSONEncoder().encode(userStats) {
            UserDefaults.standard.set(encoded, forKey: userStatsKey)
        }
        if let encoded = try? JSONEncoder().encode(appSettings) {
            UserDefaults.standard.set(encoded, forKey: appSettingsKey)
        }
    }
    
    // åŠ è½½æ•°æ®
    private func loadData() {
        if let data = UserDefaults.standard.data(forKey: transactionsKey),
           let decoded = try? JSONDecoder().decode([Transaction].self, from: data) {
            transactions = decoded
        }
        if let data = UserDefaults.standard.data(forKey: budgetKey),
           let decoded = try? JSONDecoder().decode(Budget.self, from: data) {
            budget = decoded
        }
        if let data = UserDefaults.standard.data(forKey: categoriesKey),
           let decoded = try? JSONDecoder().decode([String].self, from: data) {
            categories = decoded
        }
        if let data = UserDefaults.standard.data(forKey: achievementsKey),
           let decoded = try? JSONDecoder().decode([Achievement].self, from: data) {
            achievements = decoded
        }
        if let data = UserDefaults.standard.data(forKey: userStatsKey),
           let decoded = try? JSONDecoder().decode(UserStats.self, from: data) {
            userStats = decoded
        }
        if let data = UserDefaults.standard.data(forKey: appSettingsKey),
           let decoded = try? JSONDecoder().decode(AppSettings.self, from: data) {
            appSettings = decoded
        }
    }

    // MARK: - Achievement Management
    private func initializeAchievements() {
        if achievements.isEmpty {
            achievements = [
                Achievement(name: "è®°è´¦æ–°æ‰‹", description: "å®Œæˆé¦–æ¬¡è®°è´¦", icon: "â­", type: .firstRecord),
                Achievement(name: "åšæŒå°è¾¾äºº", description: "è¿ç»­è®°è´¦3å¤©", icon: "ğŸ”¥", type: .streak3),
                Achievement(name: "è®°è´¦è¾¾äºº", description: "è¿ç»­è®°è´¦7å¤©", icon: "ğŸ‘‘", type: .streak7),
                Achievement(name: "ä¹ æƒ¯å¤§å¸ˆ", description: "è¿ç»­è®°è´¦15å¤©", icon: "ğŸ†", type: .streak15),
                Achievement(name: "è®°è´¦ä¹‹ç‹", description: "è¿ç»­è®°è´¦30å¤©", icon: "ğŸ…", type: .streak30),
                Achievement(name: "çœé’±èƒ½æ‰‹", description: "æœˆæ”¯å‡ºæ¯”ä¸Šæœˆå‡å°‘", icon: "ğŸ’°", type: .budgetSaver),
                Achievement(name: "é¢„ç®—è¾¾äºº", description: "é¦–æ¬¡è®¾ç½®é¢„ç®—", icon: "ğŸ“Š", type: .budgetMaster),
                Achievement(name: "æ§åˆ¶å¤§å¸ˆ", description: "è¿ç»­3ä¸ªæœˆé¢„ç®—ä¸è¶…æ”¯", icon: "ğŸ›¡ï¸", type: .budgetControl)
            ]
            saveData()
        }
    }

    private func updateUserStats() {
        userStats.totalTransactions += 1

        let today = Calendar.current.startOfDay(for: Date())
        let lastRecordDay = userStats.lastRecordDate.map { Calendar.current.startOfDay(for: $0) }

        if let lastDay = lastRecordDay {
            let daysDifference = Calendar.current.dateComponents([.day], from: lastDay, to: today).day ?? 0

            if daysDifference == 1 {
                // è¿ç»­è®°è´¦
                userStats.currentStreak += 1
            } else if daysDifference > 1 {
                // è¿å‡»ä¸­æ–­
                userStats.currentStreak = 1
            }
            // daysDifference == 0 è¡¨ç¤ºåŒä¸€å¤©ï¼Œä¸å¢åŠ è¿å‡»
        } else {
            // ç¬¬ä¸€æ¬¡è®°è´¦
            userStats.currentStreak = 1
        }

        userStats.maxStreak = max(userStats.maxStreak, userStats.currentStreak)
        userStats.lastRecordDate = Date()
    }

    private func checkAchievements() {
        var newlyUnlocked: [Achievement] = []

        for i in 0..<achievements.count {
            if !achievements[i].isUnlocked {
                let shouldUnlock = checkAchievementCondition(achievements[i].type)
                if shouldUnlock {
                    achievements[i] = Achievement(
                        name: achievements[i].name,
                        description: achievements[i].description,
                        icon: achievements[i].icon,
                        type: achievements[i].type,
                        isUnlocked: true,
                        unlockedAt: Date()
                    )
                    newlyUnlocked.append(achievements[i])
                }
            }
        }

        if !newlyUnlocked.isEmpty {
            newAchievement = newlyUnlocked.first
            showAchievementAlert = true
        }
    }

    private func checkAchievementCondition(_ type: Achievement.AchievementType) -> Bool {
        switch type {
        case .firstRecord:
            return userStats.totalTransactions >= 1
        case .streak3:
            return userStats.currentStreak >= 3
        case .streak7:
            return userStats.currentStreak >= 7
        case .streak15:
            return userStats.currentStreak >= 15
        case .streak30:
            return userStats.currentStreak >= 30
        case .budgetSaver:
            // ç®€åŒ–å®ç°ï¼Œæš‚æ—¶è¿”å›false
            return false
        case .budgetMaster:
            return budget.monthlyLimit > 0
        case .budgetControl:
            // ç®€åŒ–å®ç°ï¼Œæš‚æ—¶è¿”å›false
            return false
        }
    }

    // MARK: - Export Functionality
    func getTransactionsForExport(dateRange: ExportData.DateRange) -> [Transaction] {
        let calendar = Calendar.current
        let now = Date()

        switch dateRange {
        case .allTime:
            return transactions

        case .thisMonth:
            let month = calendar.component(.month, from: now)
            let year = calendar.component(.year, from: now)
            return transactions.filter { transaction in
                let tMonth = calendar.component(.month, from: transaction.date)
                let tYear = calendar.component(.year, from: transaction.date)
                return tMonth == month && tYear == year
            }

        case .lastMonth:
            // æœ€è¿‘30å¤©çš„äº¤æ˜“ï¼Œè€Œä¸æ˜¯ä¸Šä¸ªè‡ªç„¶æœˆ
            let thirtyDaysAgo = calendar.date(byAdding: .day, value: -30, to: now) ?? now
            return transactions.filter { $0.date >= thirtyDaysAgo }

        case .lastThreeMonths:
            let threeMonthsAgo = calendar.date(byAdding: .month, value: -3, to: now) ?? now
            return transactions.filter { $0.date >= threeMonthsAgo }

        case .thisYear:
            let year = calendar.component(.year, from: now)
            return transactions.filter { transaction in
                let tYear = calendar.component(.year, from: transaction.date)
                return tYear == year
            }
        }
    }

    func exportDataAsCSV(transactions: [Transaction]) -> String {
        var csv = "æ—¥æœŸ,ç±»å‹,é‡‘é¢,åˆ†ç±»,å¤‡æ³¨\n"

        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd HH:mm:ss"
        formatter.locale = Locale(identifier: "zh_CN")

        for transaction in transactions.sorted(by: { $0.date > $1.date }) {
            let dateString = formatter.string(from: transaction.date)
            let typeString = transaction.isExpense ? "æ”¯å‡º" : "æ”¶å…¥"
            let amountString = String(format: "%.2f", transaction.amount)
            let categoryString = transaction.category
            let noteString = transaction.note.replacingOccurrences(of: ",", with: "ï¼Œ") // æ›¿æ¢é€—å·é¿å… CSV æ ¼å¼é—®é¢˜

            csv += "\(dateString),\(typeString),\(amountString),\(categoryString),\(noteString)\n"
        }

        return csv
    }

    func exportDataAsText(transactions: [Transaction]) -> String {
        var text = "è®°è´¦æ•°æ®å¯¼å‡º\n"
        text += "===================\n\n"

        let formatter = DateFormatter()
        formatter.dateFormat = "yyyyå¹´MMæœˆddæ—¥ HH:mm"
        formatter.locale = Locale(identifier: "zh_CN")

        let groupedTransactions = Dictionary(grouping: transactions.sorted(by: { $0.date > $1.date })) { transaction in
            Calendar.current.dateInterval(of: .day, for: transaction.date)?.start ?? transaction.date
        }

        let sortedKeys = groupedTransactions.keys.sorted(by: >)

        for date in sortedKeys {
            let dayFormatter = DateFormatter()
            dayFormatter.dateFormat = "yyyyå¹´MMæœˆddæ—¥"
            dayFormatter.locale = Locale(identifier: "zh_CN")
            text += dayFormatter.string(from: date) + "\n"
            text += "-----------\n"

            let dayTransactions = groupedTransactions[date] ?? []
            var dayTotal: Double = 0

            for transaction in dayTransactions {
                let timeString = formatter.string(from: transaction.date).components(separatedBy: " ")[1]
                let typeString = transaction.isExpense ? "æ”¯å‡º" : "æ”¶å…¥"
                let amountString = String(format: "%.2f", transaction.amount)
                text += "\(timeString) [\(typeString)] Â¥\(amountString) - \(transaction.category)\n"
                text += "  å¤‡æ³¨: \(transaction.note)\n"

                if transaction.isExpense {
                    dayTotal += transaction.amount
                }
            }

            text += "å½“æ—¥æ”¯å‡ºå°è®¡: Â¥\(String(format: "%.2f", dayTotal))\n\n"
        }

        let totalExpense = transactions.filter { $0.isExpense }.reduce(0) { $0 + $1.amount }
        let totalIncome = transactions.filter { !$0.isExpense }.reduce(0) { $0 + $1.amount }

        text += "===================\n"
        text += "æ€»ç»Ÿè®¡:\n"
        text += "æ€»æ”¯å‡º: Â¥\(String(format: "%.2f", totalExpense))\n"
        text += "æ€»æ”¶å…¥: Â¥\(String(format: "%.2f", totalIncome))\n"
        text += "å‡€æ”¯å‡º: Â¥\(String(format: "%.2f", totalExpense - totalIncome))\n"

        return text
    }

    // MARK: - Budget Warning System
    private func checkBudgetWarnings(for transaction: Transaction) {
        guard transaction.isExpense && appSettings.budgetWarningEnabled else { return }

        let categoryLimit = budget.categoryLimits[transaction.category] ?? 0
        guard categoryLimit > 0 else { return }

        let categoryExpense = getCategoryExpense(category: transaction.category)
        let percentage = categoryExpense / categoryLimit

        // åªåœ¨70%å’Œ90%é˜ˆå€¼æ—¶å‘é€é€šçŸ¥
        if percentage >= 0.7 && percentage < 0.75 {
            NotificationManager.shared.scheduleBudgetWarning(category: transaction.category, percentage: percentage)
        } else if percentage >= 0.9 && percentage < 0.95 {
            NotificationManager.shared.scheduleBudgetWarning(category: transaction.category, percentage: percentage)
        }
    }
}

// MARK: - Voice Recognition Manager
class VoiceRecognitionManager: NSObject, ObservableObject {
    @Published var isRecording = false
    @Published var recognizedText = ""
    @Published var errorMessage = ""
    
    private var speechRecognizer: SFSpeechRecognizer? = SFSpeechRecognizer(locale: Locale(identifier: "zh-CN"))
    private var recognitionRequest: SFSpeechAudioBufferRecognitionRequest?
    private var recognitionTask: SFSpeechRecognitionTask?
    private let audioEngine = AVAudioEngine()
    
    override init() {
        super.init()
        requestAuthorization()
    }
    
    func requestAuthorization() {
        // è¯·æ±‚è¯­éŸ³è¯†åˆ«æƒé™
        SFSpeechRecognizer.requestAuthorization { authStatus in
            DispatchQueue.main.async {
                switch authStatus {
                case .authorized:
                    print("âœ… è¯­éŸ³è¯†åˆ«å·²æˆæƒ")
                case .denied:
                    self.errorMessage = "è¯­éŸ³è¯†åˆ«æƒé™è¢«æ‹’ç»ï¼Œè¯·åœ¨è®¾ç½®ä¸­å¼€å¯"
                    print("âŒ è¯­éŸ³è¯†åˆ«æƒé™è¢«æ‹’ç»")
                case .restricted:
                    self.errorMessage = "è¯­éŸ³è¯†åˆ«æƒé™è¢«é™åˆ¶"
                    print("âŒ è¯­éŸ³è¯†åˆ«æƒé™è¢«é™åˆ¶")
                case .notDetermined:
                    self.errorMessage = "è¯­éŸ³è¯†åˆ«æƒé™æœªç¡®å®š"
                    print("âš ï¸ è¯­éŸ³è¯†åˆ«æƒé™æœªç¡®å®š")
                @unknown default:
                    self.errorMessage = "æœªçŸ¥è¯­éŸ³è¯†åˆ«æƒé™çŠ¶æ€"
                    print("âŒ æœªçŸ¥è¯­éŸ³è¯†åˆ«æƒé™çŠ¶æ€")
                }
            }
        }

        // è¯·æ±‚éº¦å…‹é£æƒé™
        AVAudioSession.sharedInstance().requestRecordPermission { granted in
            DispatchQueue.main.async {
                if granted {
                    print("âœ… éº¦å…‹é£æƒé™å·²æˆæƒ")
                } else {
                    self.errorMessage = "éº¦å…‹é£æƒé™è¢«æ‹’ç»ï¼Œè¯·åœ¨è®¾ç½®ä¸­å¼€å¯"
                    print("âŒ éº¦å…‹é£æƒé™è¢«æ‹’ç»")
                }
            }
        }
    }
    
    func startRecording() {
        print("ğŸ¤ å¼€å§‹å½•éŸ³...")

        if audioEngine.isRunning {
            stopRecording()
            return
        }

        // æ£€æŸ¥è¯­éŸ³è¯†åˆ«å™¨çŠ¶æ€
        guard let recognizer = speechRecognizer, recognizer.isAvailable else {
            errorMessage = "è¯­éŸ³è¯†åˆ«ä¸å¯ç”¨"
            print("âŒ è¯­éŸ³è¯†åˆ«å™¨ä¸å¯ç”¨")
            return
        }

        recognizedText = ""
        errorMessage = ""
        
        let audioSession = AVAudioSession.sharedInstance()
        do {
            try audioSession.setCategory(.record, mode: .measurement, options: .duckOthers)
            try audioSession.setActive(true, options: .notifyOthersOnDeactivation)
        } catch {
            errorMessage = "éŸ³é¢‘ä¼šè¯è®¾ç½®å¤±è´¥"
            return
        }
        
        recognitionRequest = SFSpeechAudioBufferRecognitionRequest()
        
        let inputNode = audioEngine.inputNode
        guard let recognitionRequest = recognitionRequest else { return }
        
        recognitionRequest.shouldReportPartialResults = true
        
        guard let recognizer = speechRecognizer else {
            print("âŒ è¯­éŸ³è¯†åˆ«å™¨ä¸ºç©º")
            return
        }

        recognitionTask = recognizer.recognitionTask(with: recognitionRequest) { result, error in
            DispatchQueue.main.async {
                if let result = result {
                    self.recognizedText = result.bestTranscription.formattedString
                    print("ğŸ” è¯†åˆ«åˆ°æ–‡æœ¬: \(self.recognizedText)")
                }

                if let error = error {
                    self.errorMessage = "è¯­éŸ³è¯†åˆ«é”™è¯¯: \(error.localizedDescription)"
                    print("âŒ è¯­éŸ³è¯†åˆ«é”™è¯¯: \(error)")
                }

                if error != nil || result?.isFinal == true {
                    self.audioEngine.stop()
                    inputNode.removeTap(onBus: 0)
                    self.recognitionRequest = nil
                    self.recognitionTask = nil
                    self.isRecording = false
                    print("ğŸ”š å½•éŸ³ç»“æŸ")
                }
            }
        }
        
        let recordingFormat = inputNode.outputFormat(forBus: 0)
        inputNode.installTap(onBus: 0, bufferSize: 1024, format: recordingFormat) { buffer, _ in
            self.recognitionRequest?.append(buffer)
        }
        
        audioEngine.prepare()
        
        do {
            try audioEngine.start()
            isRecording = true
        } catch {
            errorMessage = "æ— æ³•å¯åŠ¨éŸ³é¢‘å¼•æ“"
        }
    }
    
    func stopRecording() {
        audioEngine.stop()
        recognitionRequest?.endAudio()
        isRecording = false
    }
    
    // è§£æå¤šç¬”äº¤æ˜“
    func parseMultipleTransactions(from text: String) -> [(amount: Double?, category: String?, note: String?)] {
        print("ğŸ”„ å¼€å§‹è§£æå¤šç¬”äº¤æ˜“: \"\(text)\"")

        // å°è¯•æ‰¾åˆ°æ‰€æœ‰é‡‘é¢
        let amountPattern = "\\d+(\\.\\d+)?"
        let amountRegex = try? NSRegularExpression(pattern: amountPattern, options: [])
        let amountMatches = amountRegex?.matches(in: text, options: [], range: NSRange(location: 0, length: text.count)) ?? []

        print("ğŸ’° å‘ç° \(amountMatches.count) ä¸ªé‡‘é¢")
        for (i, match) in amountMatches.enumerated() {
            let range = Range(match.range, in: text)!
            let amountText = String(text[range])
            print("  é‡‘é¢\(i+1): '\(amountText)' at \(match.range.location)")
        }

        // å¦‚æœåªæœ‰ä¸€ä¸ªé‡‘é¢ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰"å„"å­—è¡¨ç¤ºå¤šç¬”ç›¸åŒé‡‘é¢çš„äº¤æ˜“
        if amountMatches.count <= 1 {
            if text.contains("å„") {
                print("ğŸ“ å‘ç°'å„'å­—ï¼Œå¯èƒ½æ˜¯å¤šç¬”ç›¸åŒé‡‘é¢äº¤æ˜“")
                return parseEachTransaction(from: text)
            } else {
                print("ğŸ“ å•ç¬”äº¤æ˜“ï¼Œä½¿ç”¨åŸå§‹è§£æ")
                let transaction = parseTransaction(from: text)
                return transaction.amount != nil ? [transaction] : []
            }
        }

        // å¤šä¸ªé‡‘é¢çš„æƒ…å†µï¼Œéœ€è¦æ™ºèƒ½åˆ†å‰²
        var segments: [String] = []

        // æ–¹æ³•1ï¼šåŸºäºå…³é”®åˆ†éš”ç¬¦åˆ†å‰²
        let separators = ["ï¼Œ", ",", "è¿˜æœ‰", "å¦å¤–", "ç„¶å", "æ¥ç€", "å†", " å’Œ ", "å„"]

        // æ‰¾åˆ°æœ€ä½³çš„åˆ†éš”ç¬¦
        var bestSeparator: String? = nil
        var maxSegments = 1

        for separator in separators {
            let testSegments = text.components(separatedBy: separator)
            if testSegments.count > maxSegments {
                maxSegments = testSegments.count
                bestSeparator = separator
            }
        }

        if let separator = bestSeparator {
            segments = text.components(separatedBy: separator)
            print("ğŸ“Š ä½¿ç”¨åˆ†éš”ç¬¦ '\(separator)' åˆ†å‰²æˆ \(segments.count) ä¸ªç‰‡æ®µ: \(segments)")
        } else {
            print("ğŸ“Š æ²¡æœ‰æ‰¾åˆ°åˆ†éš”ç¬¦ï¼Œä½¿ç”¨é‡‘é¢ä½ç½®åˆ†å‰²")
            // æ–¹æ³•2ï¼šæŒ‰ç…§é‡‘é¢ä½ç½®æ™ºèƒ½åˆ†å‰²
            segments = splitByAmountPositions(text: text, amountMatches: amountMatches)
        }

        // æ¸…ç†ç‰‡æ®µ
        segments = segments.map { $0.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines) }
                          .filter { !$0.isEmpty && $0.count > 1 }

        print("ğŸ“Š æ¸…ç†åå¾—åˆ° \(segments.count) ä¸ªç‰‡æ®µ: \(segments)")

        // è§£ææ¯ä¸ªç‰‡æ®µ
        var transactions: [(amount: Double?, category: String?, note: String?)] = []
        for segment in segments {
            let transaction = parseTransaction(from: segment)
            // åªæ·»åŠ æœ‰é‡‘é¢çš„äº¤æ˜“
            if transaction.amount != nil {
                transactions.append(transaction)
                print("âœ… è§£ææˆåŠŸ: é‡‘é¢=\(transaction.amount ?? 0), åˆ†ç±»=\(transaction.category ?? ""), å¤‡æ³¨=\(transaction.note ?? "")")
            }
        }

        print("ğŸ“ˆ å…±è§£æå‡º \(transactions.count) ç¬”äº¤æ˜“")
        return transactions
    }

    // æŒ‰é‡‘é¢ä½ç½®æ™ºèƒ½åˆ†å‰²æ–‡æœ¬ï¼Œæ¯ä¸ªé‡‘é¢å¯¹åº”ä¸€ä¸ªç‹¬ç«‹ç‰‡æ®µ
    private func splitByAmountPositions(text: String, amountMatches: [NSTextCheckingResult]) -> [String] {
        if amountMatches.count <= 1 {
            return [text]
        }

        var segments: [String] = []
        print("ğŸ”§ å¼€å§‹æŒ‰\(amountMatches.count)ä¸ªé‡‘é¢ä½ç½®åˆ†å‰²æ–‡æœ¬")

        // ä¸ºæ¯ä¸ªé‡‘é¢æ‰¾åˆ°åˆç†çš„ä¸Šä¸‹æ–‡èŒƒå›´
        for (index, match) in amountMatches.enumerated() {
            let currentStart = match.range.location
            let currentEnd = match.range.location + match.range.length

            var segmentStart: Int
            var segmentEnd: Int

            if index == 0 {
                // ç¬¬ä¸€ä¸ªé‡‘é¢ï¼šä»å¼€å¤´å¼€å§‹
                segmentStart = 0
                // ç»“æŸç‚¹ï¼šåˆ°ç¬¬äºŒä¸ªé‡‘é¢å¼€å§‹å‰çš„åˆç†ä½ç½®
                if index + 1 < amountMatches.count {
                    let nextAmountStart = amountMatches[index + 1].range.location
                    // å¯»æ‰¾ä¸¤ä¸ªé‡‘é¢ä¹‹é—´çš„åˆ†ç•Œç‚¹
                    segmentEnd = findBoundaryBetweenAmounts(text: text,
                                                          firstAmountEnd: currentEnd,
                                                          secondAmountStart: nextAmountStart)
                } else {
                    segmentEnd = text.count
                }
            } else {
                // åç»­é‡‘é¢ï¼šä»å‰ä¸€ä¸ªåˆ†ç•Œç‚¹å¼€å§‹
                let prevAmountEnd = amountMatches[index - 1].range.location + amountMatches[index - 1].range.length
                segmentStart = findBoundaryBetweenAmounts(text: text,
                                                        firstAmountEnd: prevAmountEnd,
                                                        secondAmountStart: currentStart)

                // ç»“æŸç‚¹ï¼šå¦‚æœæœ‰ä¸‹ä¸€ä¸ªé‡‘é¢ï¼Œæ‰¾åˆ°åˆ†ç•Œç‚¹ï¼›å¦åˆ™åˆ°æ–‡æœ¬æœ«å°¾
                if index + 1 < amountMatches.count {
                    let nextAmountStart = amountMatches[index + 1].range.location
                    segmentEnd = findBoundaryBetweenAmounts(text: text,
                                                          firstAmountEnd: currentEnd,
                                                          secondAmountStart: nextAmountStart)
                } else {
                    segmentEnd = text.count
                }
            }

            // ç¡®ä¿è¾¹ç•Œåˆç†
            segmentStart = max(0, segmentStart)
            segmentEnd = min(text.count, segmentEnd)

            if segmentStart < segmentEnd {
                let range = NSRange(location: segmentStart, length: segmentEnd - segmentStart)
                if let swiftRange = Range(range, in: text) {
                    let segment = String(text[swiftRange]).trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)
                    // æ£€æŸ¥ç‰‡æ®µæ˜¯å¦åŒ…å«é‡‘é¢ï¼ˆæ•°å­—ï¼‰
                    let containsAmount = segment.range(of: "\\d+(\\.\\d+)?", options: .regularExpression) != nil
                    if !segment.isEmpty && containsAmount {
                        segments.append(segment)
                        print("ğŸ”§ ç‰‡æ®µ \(index + 1): \"\(segment)\"")
                    }
                }
            }
        }

        print("ğŸ”§ é€šè¿‡é‡‘é¢ä½ç½®åˆ†å‰²å¾—åˆ° \(segments.count) ä¸ªæœ‰æ•ˆç‰‡æ®µ")
        return segments
    }

    // å¤„ç†"å„"å­—è¡¨ç¤ºçš„å¤šç¬”ç›¸åŒé‡‘é¢äº¤æ˜“
    func parseEachTransaction(from text: String) -> [(amount: Double?, category: String?, note: String?)] {
        print("ğŸ”„ è§£æ'å„'å­—äº¤æ˜“: \"\(text)\"")

        // æå–é‡‘é¢
        let amountPattern = "\\d+(\\.\\d+)?"
        var amount: Double?
        if let range = text.range(of: amountPattern, options: .regularExpression) {
            amount = Double(text[range])
            print("ğŸ’° æå–åˆ°é‡‘é¢: \(amount ?? 0)")
        }

        guard let validAmount = amount else {
            print("âŒ æœªæ‰¾åˆ°æœ‰æ•ˆé‡‘é¢")
            return []
        }

        // æŸ¥æ‰¾"å„"å­—ä¹‹å‰çš„éƒ¨åˆ†ï¼Œå¯»æ‰¾å¤šä¸ªæ—¶é—´æˆ–æ´»åŠ¨
        let eachPosition = text.range(of: "å„")
        let beforeEach: String
        if let eachRange = eachPosition {
            beforeEach = String(text[..<eachRange.lowerBound])
        } else {
            beforeEach = text
        }

        print("ğŸ“ 'å„'å­—å‰çš„å†…å®¹: \"\(beforeEach)\"")

        // å¯»æ‰¾æ—¶é—´æ ‡è®°æˆ–è¿æ¥è¯
        var timeMarkers: [String] = []
        let timeKeywords = ["æ—©ä¸Š", "ä¸­åˆ", "ä¸‹åˆ", "æ™šä¸Š", "æ˜¨å¤©", "ä»Šå¤©", "æ˜å¤©"]

        for keyword in timeKeywords {
            if beforeEach.contains(keyword) {
                timeMarkers.append(keyword)
            }
        }

        // å¦‚æœæ‰¾åˆ°å¤šä¸ªæ—¶é—´æ ‡è®°ï¼Œä¸ºæ¯ä¸ªåˆ›å»ºä¸€ç¬”äº¤æ˜“
        if timeMarkers.count >= 2 {
            print("ğŸ• æ‰¾åˆ°å¤šä¸ªæ—¶é—´æ ‡è®°: \(timeMarkers)")
            var transactions: [(amount: Double?, category: String?, note: String?)] = []

            for timeMarker in timeMarkers {
                // ä¸ºæ¯ä¸ªæ—¶é—´æ ‡è®°åˆ›å»ºä¸€ä¸ªè™šæ‹Ÿç‰‡æ®µæ¥è§£æ
                let virtualSegment = "\(timeMarker)åƒé¥­\(validAmount)"
                let transaction = parseTransaction(from: virtualSegment)
                if transaction.amount != nil || validAmount > 0 {
                    // ä½¿ç”¨åŸå§‹é‡‘é¢ï¼Œé¿å…è§£æé”™è¯¯
                    let finalTransaction = (
                        amount: validAmount,
                        category: transaction.category,
                        note: transaction.note
                    )
                    transactions.append(finalTransaction)
                    print("âœ… åˆ›å»ºäº¤æ˜“: \(timeMarker) - \(validAmount)å…ƒ")
                }
            }

            return transactions
        } else {
            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å¤šä¸ªæ—¶é—´æ ‡è®°ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰"å’Œ"è¿æ¥çš„æ´»åŠ¨
            if beforeEach.contains("å’Œ") {
                let parts = beforeEach.components(separatedBy: "å’Œ")
                if parts.count >= 2 {
                    print("ğŸ”— æ‰¾åˆ°'å’Œ'è¿æ¥çš„å¤šä¸ªéƒ¨åˆ†: \(parts)")
                    var transactions: [(amount: Double?, category: String?, note: String?)] = []

                    for part in parts {
                        let trimmedPart = part.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)
                        if !trimmedPart.isEmpty {
                            let virtualSegment = "\(trimmedPart)åƒé¥­\(validAmount)"
                            let transaction = parseTransaction(from: virtualSegment)
                            let finalTransaction = (
                                amount: validAmount,
                                category: transaction.category,
                                note: transaction.note
                            )
                            transactions.append(finalTransaction)
                            print("âœ… åˆ›å»ºäº¤æ˜“: \(trimmedPart) - \(validAmount)å…ƒ")
                        }
                    }

                    return transactions
                }
            }
        }

        // å¦‚æœæ— æ³•åˆ†å‰²ï¼Œè¿”å›å•ç¬”äº¤æ˜“
        print("ğŸ“ æ— æ³•åˆ†å‰²ï¼Œè¿”å›å•ç¬”äº¤æ˜“")
        let transaction = parseTransaction(from: text)
        return transaction.amount != nil ? [transaction] : []
    }

    // åœ¨ä¸¤ä¸ªé‡‘é¢ä¹‹é—´æ‰¾åˆ°åˆé€‚çš„åˆ†ç•Œç‚¹
    private func findBoundaryBetweenAmounts(text: String, firstAmountEnd: Int, secondAmountStart: Int) -> Int {
        let searchStart = firstAmountEnd
        let searchEnd = secondAmountStart

        if searchStart >= searchEnd {
            return searchStart
        }

        // åœ¨ä¸¤ä¸ªé‡‘é¢ä¹‹é—´å¯»æ‰¾è¯­ä¹‰åˆ†ç•Œç‚¹
        let searchRange = searchStart..<min(searchEnd, text.count)

        // å¯»æ‰¾æ—¶é—´è¯æ±‡ä½œä¸ºåˆ†ç•Œç‚¹
        let timeMarkers = ["æ—©ä¸Š", "ä¸­åˆ", "ä¸‹åˆ", "æ™šä¸Š", "æ˜¨å¤©", "ä»Šå¤©", "æ˜å¤©"]

        for pos in searchRange {
            let remainingText = String(text.suffix(from: text.index(text.startIndex, offsetBy: pos)))

            for marker in timeMarkers {
                if remainingText.hasPrefix(marker) {
                    print("ğŸ¯ åœ¨ä½ç½®\(pos)æ‰¾åˆ°æ—¶é—´æ ‡è®°'\(marker)'ä½œä¸ºåˆ†ç•Œç‚¹")
                    return pos
                }
            }
        }

        // å¦‚æœæ²¡æ‰¾åˆ°æ—¶é—´æ ‡è®°ï¼Œè¿”å›ä¸­ç‚¹
        let midpoint = (searchStart + searchEnd) / 2
        print("ğŸ¯ ä½¿ç”¨ä¸­ç‚¹ä½ç½®\(midpoint)ä½œä¸ºåˆ†ç•Œç‚¹")
        return midpoint
    }

    // è§£æè¯†åˆ«çš„æ–‡æœ¬ï¼ˆå•ç¬”äº¤æ˜“ï¼‰
    func parseTransaction(from text: String) -> (amount: Double?, category: String?, note: String?) {
        print("ğŸ” è§£æå•ç¬”äº¤æ˜“: \"\(text)\"")

        var amount: Double?
        var category: String?

        // æå–é‡‘é¢
        let amountPattern = "\\d+(\\.\\d+)?"
        if let range = text.range(of: amountPattern, options: .regularExpression) {
            amount = Double(text[range])
            print("ğŸ’° æå–åˆ°é‡‘é¢: \(amount ?? 0)")
        }

        // æ™ºèƒ½æ¸…ç†å¤‡æ³¨ï¼Œä¿ç•™å…³é”®ä¿¡æ¯
        var cleanNote = text

        // å»æ‰é‡‘é¢æ•°å­—ä½†ä¿ç•™ä¸Šä¸‹æ–‡
        let amountRegex = try? NSRegularExpression(pattern: amountPattern, options: [])
        if let regex = amountRegex {
            cleanNote = regex.stringByReplacingMatches(
                in: cleanNote,
                options: [],
                range: NSRange(location: 0, length: cleanNote.count),
                withTemplate: ""
            )
        }

        // æå–å…³é”®æ—¶é—´å’Œåœºæ™¯ä¿¡æ¯
        let timeKeywords = ["æ—©ä¸Š", "ä¸­åˆ", "ä¸‹åˆ", "æ™šä¸Š", "æ˜¨å¤©", "ä»Šå¤©", "æ˜å¤©"]
        let actionKeywords = ["åƒé¥­", "å–", "ä¹°", "è´­ä¹°", "æ‰“è½¦", "å……å€¼", "çœ‹ç”µå½±", "è´­ç‰©"]
        let placeKeywords = ["è¶…å¸‚", "é¤å…", "å•†åœº", "åœ°é“", "å…¬äº¤", "åŒ»é™¢", "å­¦æ ¡"]

        var keyInfo: [String] = []

        // åªä¿ç•™å½“å‰æ–‡æœ¬ç‰‡æ®µä¸­å®é™…å­˜åœ¨çš„å…³é”®è¯ï¼Œé¿å…é‡å¤
        let currentText = text  // ä½¿ç”¨åŸå§‹è¾“å…¥æ–‡æœ¬è€Œä¸æ˜¯cleanNote

        // ä¿ç•™æ—¶é—´ä¿¡æ¯ï¼ˆåªå–ç¬¬ä¸€ä¸ªåŒ¹é…çš„æ—¶é—´å…³é”®è¯ï¼‰
        var timeFound = false
        for keyword in timeKeywords {
            if currentText.contains(keyword) && !timeFound {
                keyInfo.append(keyword)
                timeFound = true
                break  // åªå–ä¸€ä¸ªæ—¶é—´å…³é”®è¯
            }
        }

        // ä¿ç•™åŠ¨ä½œä¿¡æ¯ï¼ˆåªå–ç¬¬ä¸€ä¸ªåŒ¹é…çš„åŠ¨ä½œå…³é”®è¯ï¼‰
        var actionFound = false
        for keyword in actionKeywords {
            if currentText.contains(keyword) && !actionFound {
                keyInfo.append(keyword)
                actionFound = true
                break  // åªå–ä¸€ä¸ªåŠ¨ä½œå…³é”®è¯
            }
        }

        // ä¿ç•™åœ°ç‚¹ä¿¡æ¯ï¼ˆåªå–ç¬¬ä¸€ä¸ªåŒ¹é…çš„åœ°ç‚¹å…³é”®è¯ï¼‰
        var placeFound = false
        for keyword in placeKeywords {
            if currentText.contains(keyword) && !placeFound {
                keyInfo.append(keyword)
                placeFound = true
                break  // åªå–ä¸€ä¸ªåœ°ç‚¹å…³é”®è¯
            }
        }

        // å¦‚æœæœ‰å…³é”®ä¿¡æ¯ï¼Œç”Ÿæˆç®€æ´æè¿°
        if !keyInfo.isEmpty {
            cleanNote = keyInfo.joined(separator: " ")
        } else {
            // æ¸…ç†æ— æ„ä¹‰çš„ä¿®é¥°è¯
            let unwantedWords = ["å—", "å…ƒ", "èŠ±äº†", "æ”¯ä»˜", "äº†", "çš„", "ã€‚", "ï¼Œ", ","]
            for word in unwantedWords {
                cleanNote = cleanNote.replacingOccurrences(of: word, with: " ")
            }

            // æ¸…ç†ç©ºæ ¼
            cleanNote = cleanNote
                .components(separatedBy: CharacterSet.whitespacesAndNewlines)
                .filter { !$0.isEmpty && $0.count > 0 }
                .joined(separator: " ")
                .trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)
        }

        // å¦‚æœæ¸…ç†åä¸ºç©ºæˆ–å¤ªçŸ­ï¼Œä½¿ç”¨åŸæ–‡æœ¬çš„å‰å‡ ä¸ªå­—ç¬¦
        let note = cleanNote.count >= 2 ? cleanNote : String(text.prefix(10))
        print("ğŸ“ ç”Ÿæˆå¤‡æ³¨: \"\(note)\"")
        
        // æ™ºèƒ½åˆ†ç±»è¯†åˆ« - æŒ‰ä¼˜å…ˆçº§åŒ¹é…å…³é”®è¯
        // å…·ä½“å…³é”®è¯ä¼˜å…ˆçº§é«˜äºé€šç”¨å…³é”®è¯
        let priorityCategories = [
            ("é¤é¥®", ["å¥¶èŒ¶", "å’–å•¡", "èŒ¶", "é¥®æ–™", "åƒé¥­", "åˆé¤", "æ™šé¤", "æ—©é¤", "é¥­", "èœ", "é¤å…", "å¤–å–", "ç‚¹é¤", "èšé¤", "å®µå¤œ", "é›¶é£Ÿ", "å°åƒ"]),
            ("äº¤é€š", [
                // ä¼ ç»Ÿäº¤é€šå·¥å…·
                "åœ°é“", "å…¬äº¤", "æ‰“è½¦", "æ»´æ»´", "å‡ºç§Ÿè½¦", "ç«è½¦", "é«˜é“", "é£æœº",
                // å…±äº«å‡ºè¡ŒæœåŠ¡
                "å…±äº«å•è½¦", "æ‘©æ‹œ", "å“ˆå•°", "é’æ¡”", "å°è“è½¦", "ofo", "å•è½¦åŒ…æœˆ", "å•è½¦å……å€¼",
                "å…±äº«æ±½è½¦", "GoFun", "EVCARD", "ç›¼è¾¾", "car2go",
                // äº¤é€šå¡å……å€¼åœºæ™¯  
                "å……å¡", "åœ°é“å……å¡", "å…¬äº¤å¡å……å€¼", "äº¤é€šå¡", "ä¸€å¡é€š", "ç¾ŠåŸé€š", "æ·±åœ³é€š",
                "äº¤é€šå……å€¼", "åœ°é“å……å€¼", "å…¬äº¤å……å€¼",
                // äº¤é€šå¥—é¤æœåŠ¡
                "äº¤é€šåŒ…æœˆ", "åœ°é“æœˆå¡", "å…¬äº¤æœˆå¡", "äº¤é€šå­£å¡", "äº¤é€šå¹´å¡",
                // ç½‘çº¦è½¦å¹³å°
                "ç¾å›¢æ‰“è½¦", "æ›¹æ“å‡ºè¡Œ", "ç¥å·ä¸“è½¦", "é¦–æ±½çº¦è½¦", "T3å‡ºè¡Œ",
                // ç¥¨åŠ¡ç›¸å…³
                "æœºç¥¨", "è½¦ç¥¨", "èˆ¹ç¥¨", "åœ°é“ç¥¨", "å…¬äº¤ç¥¨", "é«˜é“ç¥¨", "åŠ¨è½¦ç¥¨",
                // æ±½è½¦ç›¸å…³
                "åŠ æ²¹", "æ²¹è´¹", "åœè½¦è´¹", "è¿‡è·¯è´¹", "é«˜é€Ÿè´¹", "ETC", "æ´—è½¦è´¹",
                "æ±½è½¦ä¿å…»", "è½¦è¾†ç»´ä¿®", "æ±½è½¦å¹´æ£€", "è½¦é™©",
                // å‡ºè¡Œè´¹ç”¨
                "æ‰“è½¦è´¹", "è½¦è´¹", "è·¯è´¹", "äº¤é€šè´¹", "å‡ºè¡Œè´¹", "é€šå‹¤è´¹", "ç­è½¦è´¹"
            ]),
            ("å¨±ä¹", ["ç”µå½±", "æ¸¸æˆ", "KTV", "å”±æ­Œ", "æ—…æ¸¸", "æ™¯ç‚¹", "é—¨ç¥¨", "é…’å§", "å¨±ä¹", "çœ‹ç”µå½±", "æ¼”å‡º", "éŸ³ä¹ä¼š"]),
            ("ç”Ÿæ´»", ["æˆ¿ç§Ÿ", "æ°´ç”µè´¹", "è¯è´¹", "ç½‘è´¹", "ç‰©ä¸šè´¹", "ç”Ÿæ´»ç”¨å“", "æ´—è¡£", "ç†å‘", "ç¾å®¹", "æŒ‰æ‘©"]),
            ("åŒ»ç–—", ["åŒ»é™¢", "çœ‹ç—…", "è¯", "ä½“æ£€", "åŒ»ç–—", "æŒ‚å·", "æ²»ç–—", "åŒ»ç”Ÿ"]),
            ("æ•™è‚²", ["å­¦è´¹", "åŸ¹è®­", "è¯¾ç¨‹", "ä¹¦ç±", "å­¦ä¹ ", "æ•™è‚²", "è¾…å¯¼", "è€ƒè¯•"]),
            ("è´­ç‰©", [
                // ç”µå•†å¹³å°
                "æ·˜å®", "äº¬ä¸œ", "æ‹¼å¤šå¤š", "æŠ–éŸ³", "å¤©çŒ«", "è‹å®", "å”¯å“ä¼š", "å°çº¢ä¹¦", "å¾—ç‰©", "é—²é±¼",
                "ç¾å›¢", "é¥¿äº†ä¹ˆ", "ç›’é©¬", "å®å’šä¹°èœ", "å¤šç‚¹", "æ°¸è¾‰ç”Ÿæ´»", "æœ´æœ´",
                // å›½é™…ç”µå•†
                "äºšé©¬é€Š", "ebay", "æµ·æ·˜", "è€ƒæ‹‰", "æ´‹ç å¤´", "iHerb",
                // å‚ç›´ç”µå•†
                "å½“å½“", "ç½‘æ˜“ä¸¥é€‰", "å°ç±³æœ‰å“", "åä¸ºå•†åŸ", "Apple Store",
                // çº¿ä¸‹è´­ç‰©
                "å•†åœº", "è¶…å¸‚", "ä¾¿åˆ©åº—", "å•†åº—", "å¸‚åœº", "åº—é“º", "ä¸“å–åº—", "å…ç¨åº—",
                "å®œå®¶", "æ— å°è‰¯å“", "ä¼˜è¡£åº“", "å±ˆè‡£æ°", "ä¸‡è¾¾", "é“¶æ³°", "å¤§æ‚¦åŸ",
                // å•†å“ç±»åˆ«
                "è¡£æœ", "é‹å­", "åŒ…åŒ…", "åŒ–å¦†å“", "æŠ¤è‚¤å“", "æ—¥ç”¨å“", "ç”µå™¨", "æ‰‹æœº", "ç”µè„‘",
                "æ•°ç ", "å®¶å…·", "å®¶ç”µ", "é›¶é£Ÿ", "ç©å…·", "æ–‡å…·", "é…é¥°", "ç å®", "æ‰‹è¡¨",
                // è´­ç‰©è¡Œä¸º
                "è´­ç‰©", "ç½‘è´­", "æµ·æ·˜", "ä»£è´­", "å›¢è´­", "ç§’æ€", "æŠ¢è´­", "å‰æ‰‹"
            ]),
            ("å…¶ä»–", ["å…¶ä»–", "æ‚è´¹", "ç¤¼ç‰©", "çº¢åŒ…", "æèµ "])
        ]
        
        // æ™ºèƒ½åŒ¹é…é¢„è®¾åˆ†ç±»
        func intelligentCategoryMatch() -> String? {
            // æ’é™¤è¯¯åˆ†ç±»çš„åœºæ™¯
            let exclusions: [String: [String]] = [
                "äº¤é€š": ["ä¹°å•è½¦", "ä¹°è‡ªè¡Œè½¦", "è´­ä¹°å•è½¦", "å¥èº«å¡", "æ¸¸æ³³å¡", "ä¼šå‘˜å¡"], // é¿å…è´­ä¹°å•è½¦è¢«è¯¯åˆ†ç±»ä¸ºäº¤é€š
                "é¤é¥®": ["ä¹°èŒ¶å…·", "ä¹°å’–å•¡æœº", "èŒ¶å¶", "å’–å•¡è±†"] // é¿å…è´­ä¹°é¥®å“å·¥å…·è¢«è¯¯åˆ†ç±»ä¸ºé¤é¥®
            ]

            // æŒ‰ä¼˜å…ˆçº§é¡ºåºåŒ¹é…é¢„è®¾åˆ†ç±»
            for (categoryName, keywords) in priorityCategories {
                // æ£€æŸ¥æ˜¯å¦åº”è¯¥æ’é™¤
                if let excludeKeywords = exclusions[categoryName] {
                    var shouldExclude = false
                    for excludeKeyword in excludeKeywords {
                        if text.contains(excludeKeyword) {
                            shouldExclude = true
                            break
                        }
                    }
                    if shouldExclude {
                        continue // è·³è¿‡è¿™ä¸ªåˆ†ç±»
                    }
                }

                // æ­£å¸¸åŒ¹é…é€»è¾‘
                for keyword in keywords {
                    if text.contains(keyword) {
                        print("ğŸ“ åŒ¹é…åˆ°é¢„è®¾åˆ†ç±»å…³é”®è¯: \"\(keyword)\" -> \(categoryName)")
                        return categoryName
                    }
                }
            }
            return nil
        }

        // åŒ¹é…ç”¨æˆ·è‡ªå®šä¹‰åˆ†ç±»
        func matchCustomCategories() -> String? {
            // è·å–æ‰€æœ‰ç”¨æˆ·è‡ªå®šä¹‰åˆ†ç±»ï¼ˆæ’é™¤é»˜è®¤åˆ†ç±»ï¼‰
            let defaultCategories = ["é¤é¥®", "äº¤é€š", "è´­ç‰©", "å¨±ä¹", "ç”Ÿæ´»", "åŒ»ç–—", "æ•™è‚²", "å…¶ä»–"]
            let customCategories = DataManager.shared.categories.filter { !defaultCategories.contains($0) }

            print("ğŸ“‹ å½“å‰è‡ªå®šä¹‰åˆ†ç±»: \(customCategories)")  // è°ƒè¯•æ—¥å¿—

            // æŒ‰åˆ†ç±»åé•¿åº¦æ’åºï¼Œä¼˜å…ˆåŒ¹é…è¾ƒé•¿çš„åˆ†ç±»åï¼ˆæ›´å…·ä½“ï¼‰
            let sortedCategories = customCategories.sorted { $0.count > $1.count }

            // å…ˆè¿›è¡Œç²¾ç¡®åŒ¹é…
            for category in sortedCategories {
                print("ğŸ” å°è¯•åŒ¹é…åˆ†ç±»: \"\(category)\"")  // è°ƒè¯•æ—¥å¿—

                let lowercasedText = text.lowercased()
                let lowercasedCategory = category.lowercased()

                // 1. å®Œå…¨åŒ¹é…åˆ†ç±»åç§°ï¼ˆå¿½ç•¥å¤§å°å†™ï¼‰
                if lowercasedText.contains(lowercasedCategory) {
                    print("âœ¨ å®Œå…¨åŒ¹é…æˆåŠŸ: \(category)")
                    return category
                }

                // 2. å»æ‰ç©ºæ ¼ååŒ¹é…
                let compactCategory = lowercasedCategory.replacingOccurrences(of: " ", with: "")
                if lowercasedText.contains(compactCategory) && compactCategory.count >= 2 {
                    print("âœ¨ ç´§å‡‘åŒ¹é…æˆåŠŸ: \(category)")
                    return category
                }
            }

            // å†è¿›è¡Œåˆ†è¯åŒ¹é…
            for category in sortedCategories {
                // 3. åˆ†å‰²åˆ†ç±»åç§°ï¼ŒåŒ¹é…å„ä¸ªéƒ¨åˆ†
                let categoryWords = category.components(separatedBy: CharacterSet(charactersIn: " -_")).filter { $0.count >= 2 }

                // ä¼˜å…ˆåŒ¹é…æ‰€æœ‰å…³é”®è¯éƒ½å­˜åœ¨çš„æƒ…å†µ
                var allWordsMatch = categoryWords.count > 0
                for word in categoryWords {
                    if !text.lowercased().contains(word.lowercased()) {
                        allWordsMatch = false
                        break
                    }
                }
                if allWordsMatch && categoryWords.count > 0 {
                    print("âœ¨ å…¨éƒ¨å…³é”®è¯åŒ¹é…æˆåŠŸ: \(category)")
                    return category
                }
            }

            // æœ€åè¿›è¡Œå•è¯åŒ¹é…ï¼ˆä½†éœ€è¦æ›´ä¸¥æ ¼çš„æ¡ä»¶ï¼‰
            for category in sortedCategories {
                let categoryWords = category.components(separatedBy: CharacterSet(charactersIn: " -_")).filter { $0.count >= 2 }

                // 4. æ¸…ç†æ–‡æœ¬ååŒ¹é…
                let cleanedText = text
                    .replacingOccurrences(of: "ä¹°", with: "")
                    .replacingOccurrences(of: "è´­ä¹°", with: "")
                    .replacingOccurrences(of: "èŠ±é’±", with: "")
                    .replacingOccurrences(of: "æ”¯ä»˜", with: "")
                    .lowercased()

                // å¦‚æœåˆ†ç±»åç§°åœ¨æ¸…ç†åçš„æ–‡æœ¬ä¸­å®Œæ•´å‡ºç°
                if cleanedText.contains(category.lowercased()) {
                    print("âœ¨ æ¸…ç†åå®Œæ•´åŒ¹é…æˆåŠŸ: \(category)")
                    return category
                }

                // 5. ç‰¹æ®Šæƒ…å†µï¼šå¯¹äºåŒ…å«ç‰¹å®šå…³é”®è¯çš„åˆ†ç±»ï¼ˆå¦‚"ai"ï¼‰ï¼Œå³ä½¿æœ‰"ä¹°"ä¹Ÿä¼˜å…ˆåŒ¹é…
                let importantKeywords = ["ai", "å·¥å…·", "å­¦ä¹ ", "è¯¾ç¨‹", "åŸ¹è®­"]
                for keyword in importantKeywords {
                    if category.lowercased().contains(keyword) && text.lowercased().contains(keyword) {
                        print("âœ¨ é‡è¦å…³é”®è¯åŒ¹é…æˆåŠŸ: \(keyword) -> \(category)")
                        return category
                    }
                }
            }

            return nil
        }

        // ä¼˜åŒ–åŒ¹é…ç­–ç•¥ï¼šä¼˜å…ˆåŒ¹é…ç”¨æˆ·è‡ªå®šä¹‰åˆ†ç±»ï¼ˆæ›´å…·ä½“ï¼‰ï¼Œå†åŒ¹é…é¢„è®¾åˆ†ç±»ï¼ˆæ›´é€šç”¨ï¼‰
        print("ğŸ” è¯­éŸ³è¯†åˆ«æ–‡æœ¬: \"\(text)\"")  // è°ƒè¯•æ—¥å¿—

        // ç¬¬ä¸€ä¼˜å…ˆçº§ï¼šåŒ¹é…ç”¨æˆ·è‡ªå®šä¹‰åˆ†ç±»
        category = matchCustomCategories()
        if category != nil {
            print("âœ… åŒ¹é…åˆ°è‡ªå®šä¹‰åˆ†ç±»: \(category!)")
        }

        // ç¬¬äºŒä¼˜å…ˆçº§ï¼šåŒ¹é…é¢„è®¾åˆ†ç±»
        if category == nil {
            category = intelligentCategoryMatch()
            if category != nil {
                print("âœ… åŒ¹é…åˆ°é¢„è®¾åˆ†ç±»: \(category!)")
            }
        }

        // å¦‚æœä»æ²¡æœ‰åŒ¹é…åˆ°åˆ†ç±»ï¼Œé»˜è®¤ä½¿ç”¨"å…¶ä»–"
        if category == nil {
            category = "å…¶ä»–"
            print("âš ï¸ æœªåŒ¹é…åˆ°ä»»ä½•åˆ†ç±»ï¼Œä½¿ç”¨é»˜è®¤åˆ†ç±»: å…¶ä»–")
        }

        print("âœ… å•ç¬”äº¤æ˜“è§£æå®Œæˆ: é‡‘é¢=\(amount ?? 0), åˆ†ç±»=\(category ?? ""), å¤‡æ³¨=\(note)")
        return (amount, category, note)
    }
}

// MARK: - Notification Manager
class NotificationManager: ObservableObject {
    static let shared = NotificationManager()

    private init() {}

    func requestAuthorization(completion: @escaping (Bool) -> Void) {
        UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .badge, .sound]) { granted, _ in
            DispatchQueue.main.async {
                completion(granted)
            }
        }
    }

    func scheduleReminders(morningTime: String, afternoonTime: String, eveningTime: String) {
        // æ¸…é™¤ç°æœ‰çš„æé†’
        UNUserNotificationCenter.current().removePendingNotificationRequests(withIdentifiers: [
            "morning_reminder", "afternoon_reminder", "evening_reminder"
        ])

        // ä¸Šåˆæé†’
        if let morningDate = timeStringToDate(morningTime) {
            scheduleNotification(
                identifier: "morning_reminder",
                title: "ğŸŒ… è®°è´¦æé†’",
                body: "æ—©ä¸Šå¥½ï¼Œè®°å½•ä¸€ä¸‹åƒæ—©é¤çš„èŠ±è´¹å§~",
                date: morningDate,
                repeats: true
            )
        }

        // ä¸‹åˆæé†’
        if let afternoonDate = timeStringToDate(afternoonTime) {
            scheduleNotification(
                identifier: "afternoon_reminder",
                title: "â˜• è®°è´¦æé†’",
                body: "ä¸‹åˆèŒ¶æ—¶é—´ï¼Œæœ‰ä»€ä¹ˆå°æ¶ˆè´¹å—ï¼Ÿ",
                date: afternoonDate,
                repeats: true
            )
        }

        // æ™šä¸Šæé†’
        if let eveningDate = timeStringToDate(eveningTime) {
            scheduleNotification(
                identifier: "evening_reminder",
                title: "ğŸŒ™ è®°è´¦æé†’",
                body: "ä»Šå¤©è¿‡å¾—æ€ä¹ˆæ ·ï¼Œè®°å½•ä¸€ä¸‹å§ï¼",
                date: eveningDate,
                repeats: true
            )
        }
    }

    func scheduleBudgetWarning(category: String, percentage: Double) {
        let identifier = "budget_warning_\(category)"

        // æ¸…é™¤æ—§çš„è­¦å‘Š
        UNUserNotificationCenter.current().removePendingNotificationRequests(withIdentifiers: [identifier])

        let title: String
        let body: String

        if percentage >= 0.9 {
            title = "âš ï¸ é¢„ç®—è¶…æ”¯è­¦å‘Š"
            body = "\(category)åˆ†ç±»å·²è¶…å‡ºé¢„ç®—ï¼Œè®°å¾—ç†æ€§æ¶ˆè´¹å“¦~"
        } else {
            title = "ğŸš¨ é¢„ç®—æé†’"
            body = "\(category)åˆ†ç±»å·²ä½¿ç”¨\(Int(percentage * 100))%é¢„ç®—ï¼Œæ³¨æ„åˆç†æ¶ˆè´¹å“¦ ğŸŒˆ"
        }

        let content = UNMutableNotificationContent()
        content.title = title
        content.body = body
        content.sound = .default

        // 5ç§’åå‘é€
        let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 5, repeats: false)
        let request = UNNotificationRequest(identifier: identifier, content: content, trigger: trigger)

        UNUserNotificationCenter.current().add(request)
    }

    func scheduleWeeklyReport(totalExpense: Double) {
        let identifier = "weekly_report"

        let content = UNMutableNotificationContent()
        content.title = "ğŸ“Š æœ¬å‘¨æ”¯å‡ºæŠ¥å‘Š"
        content.body = "æœ¬å‘¨æ€»æ”¯å‡º Â¥\(String(format: "%.0f", totalExpense))ï¼Œç»§ç»­åŠ æ²¹å•Šï¼"
        content.sound = .default

        // æ¯å‘¨æ—¥æ™šä¸Š8ç‚¹
        var dateComponents = DateComponents()
        dateComponents.weekday = 1 // å‘¨æ—¥
        dateComponents.hour = 20
        dateComponents.minute = 0

        let trigger = UNCalendarNotificationTrigger(dateMatching: dateComponents, repeats: true)
        let request = UNNotificationRequest(identifier: identifier, content: content, trigger: trigger)

        UNUserNotificationCenter.current().add(request)
    }

    private func scheduleNotification(identifier: String, title: String, body: String, date: Date, repeats: Bool) {
        let content = UNMutableNotificationContent()
        content.title = title
        content.body = body
        content.sound = .default

        let calendar = Calendar.current
        let components = calendar.dateComponents([.hour, .minute], from: date)
        let trigger = UNCalendarNotificationTrigger(dateMatching: components, repeats: repeats)

        let request = UNNotificationRequest(identifier: identifier, content: content, trigger: trigger)
        UNUserNotificationCenter.current().add(request)
    }

    private func timeStringToDate(_ timeString: String) -> Date? {
        let formatter = DateFormatter()
        formatter.dateFormat = "HH:mm"
        return formatter.date(from: timeString)
    }

    func checkNotificationStatus(completion: @escaping (Bool) -> Void) {
        UNUserNotificationCenter.current().getNotificationSettings { settings in
            DispatchQueue.main.async {
                completion(settings.authorizationStatus == .authorized)
            }
        }
    }
}

// MARK: - Onboarding View
struct OnboardingView: View {
    @Binding var showOnboarding: Bool
    @State private var currentPage = 0

    var onboardingPages: [OnboardingPage] {
        return [
            OnboardingPage(
                title: "æ¬¢è¿ä½¿ç”¨è¯­éŸ³è®°è´¦æœ¬",
                subtitle: "è½»æ¾è®°å½•æ¯ä¸€ç¬”æ”¯å‡º",
                description: "åªéœ€è¯´è¯ï¼Œå°±èƒ½å¿«é€Ÿè®°å½•æ‚¨çš„æ¶ˆè´¹ï¼Œè®©è®°è´¦å˜å¾—ç®€å•æœ‰è¶£",
                iconName: "mic.circle.fill",
                iconColor: .blue
            ),
            OnboardingPage(
                title: "æ™ºèƒ½è¯­éŸ³è¯†åˆ«",
                subtitle: "æ”¯æŒå¤šç§è¡¨è¾¾æ–¹å¼",
                description: "æ”¯æŒã€Œä¸­åˆåƒé¥­10å—ã€æˆ–ã€Œä¸­åˆå’Œæ™šä¸Šåƒé¥­å„15å…ƒã€ç­‰è‡ªç„¶è¯­è¨€è¡¨è¾¾",
                iconName: "waveform.circle.fill",
                iconColor: .green
            ),
            OnboardingPage(
                title: "æ¸¸æˆåŒ–ä½“éªŒ",
                subtitle: "è®©è®°è´¦å……æ»¡ä¹è¶£",
                description: "è§£é”æˆå°±ã€ç»´æŒè¿å‡»ï¼Œé€šè¿‡æ¸¸æˆåŒ–å…ƒç´ åŸ¹å…»è‰¯å¥½çš„è®°è´¦ä¹ æƒ¯",
                iconName: "trophy.circle.fill",
                iconColor: .orange
            )
        ]
    }

    var body: some View {
        VStack {
            // é¡µé¢æŒ‡ç¤ºå™¨
            HStack {
                Spacer()
                HStack(spacing: 8) {
                    ForEach(0..<onboardingPages.count, id: \.self) { index in
                        Circle()
                            .fill(currentPage == index ? Color.blue : Color.gray.opacity(0.3))
                            .frame(width: 8, height: 8)
                    }
                }
                Spacer()
            }
            .padding(.top, 50)

            // é¡µé¢å†…å®¹
            TabView(selection: $currentPage) {
                ForEach(0..<onboardingPages.count, id: \.self) { index in
                    OnboardingPageView(page: onboardingPages[index])
                        .tag(index)
                }
            }
            .tabViewStyle(PageTabViewStyle(indexDisplayMode: .never))

            // åº•éƒ¨æŒ‰é’®
            VStack(spacing: 16) {
                if currentPage == onboardingPages.count - 1 {
                    // æœ€åä¸€é¡µæ˜¾ç¤ºå¼€å§‹ä½¿ç”¨æŒ‰é’®
                    Button(action: {
                        showOnboarding = false
                    }) {
                        Text("å¼€å§‹ä½¿ç”¨")
                            .font(.headline)
                            .foregroundColor(.white)
                            .frame(maxWidth: .infinity)
                            .padding()
                            .background(Color.blue)
                            .cornerRadius(12)
                    }
                } else {
                    // å…¶ä»–é¡µé¢æ˜¾ç¤ºä¸‹ä¸€æ­¥å’Œè·³è¿‡
                    HStack {
                        Button("è·³è¿‡") {
                            showOnboarding = false
                        }
                        .foregroundColor(.gray)

                        Spacer()

                        Button("ä¸‹ä¸€æ­¥") {
                            withAnimation(.easeInOut(duration: 0.3), {
                                currentPage += 1
                            })
                        }
                        .font(.system(size: 17, weight: .semibold))
                        .foregroundColor(.blue)
                    }
                }
            }
            .padding(.horizontal, 24)
            .padding(.bottom, 50)
        }
        .background(Color(UIColor.systemBackground))
    }
}

struct OnboardingPage {
    let title: String
    let subtitle: String
    let description: String
    let iconName: String
    let iconColor: Color
}

struct OnboardingPageView: View {
    let page: OnboardingPage

    var body: some View {
        VStack(spacing: 40) {
            Spacer()

            // å›¾æ ‡
            Image(systemName: page.iconName)
                .font(.system(size: 80))
                .foregroundColor(page.iconColor)

            // æ–‡å­—å†…å®¹
            VStack(spacing: 16) {
                Text(page.title)
                    .font(.system(size: 28, weight: .bold))
                    .multilineTextAlignment(.center)

                Text(page.subtitle)
                    .font(.title3)
                    .foregroundColor(.secondary)
                    .multilineTextAlignment(.center)

                Text(page.description)
                    .font(.body)
                    .foregroundColor(.secondary)
                    .multilineTextAlignment(.center)
                    .padding(.horizontal, 32)
                    .lineLimit(nil)
            }

            Spacer()
        }
    }
}

// MARK: - Main Content View
struct ContentView: View {
    @State private var selectedTab = 0
    @AppStorage("hasCompletedOnboarding") private var hasCompletedOnboarding = false
    @State private var showOnboarding = false

    var body: some View {
        Group {
            if showOnboarding {
                OnboardingView(showOnboarding: $showOnboarding)
            } else {
                TabView(selection: $selectedTab) {
                    HomeView()
                        .tabItem {
                            Image(systemName: "house.fill")
                            Text("é¦–é¡µ")
                        }
                        .tag(0)

                    RecordsView()
                        .tabItem {
                            Image(systemName: "list.bullet")
                            Text("è®°å½•")
                        }
                        .tag(1)

                    BudgetView()
                        .tabItem {
                            Image(systemName: "chart.pie.fill")
                            Text("é¢„ç®—")
                        }
                        .tag(2)

                    AnalyticsView()
                        .tabItem {
                            Image(systemName: "chart.bar.fill")
                            Text("ç»Ÿè®¡")
                        }
                        .tag(3)

                    SettingsView()
                        .tabItem {
                            Image(systemName: "gear")
                            Text("è®¾ç½®")
                        }
                        .tag(4)
                }
            }
        }
        .onAppear {
            // å¦‚æœç”¨æˆ·æ²¡æœ‰å®Œæˆå¼•å¯¼ï¼Œæ˜¾ç¤ºå¼•å¯¼é¡µ
            if !hasCompletedOnboarding {
                showOnboarding = true
            }
        }
        .onChange(of: showOnboarding) { newValue in
            // å½“å¼•å¯¼é¡µå…³é—­æ—¶ï¼Œæ ‡è®°ä¸ºå·²å®Œæˆå¼•å¯¼
            if !newValue {
                hasCompletedOnboarding = true
            }
        }
    }
}

// MARK: - Home View
struct HomeView: View {
    @EnvironmentObject var dataManager: DataManager
    @StateObject private var voiceManager = VoiceRecognitionManager()
    @State private var showingAddTransaction = false
    @State private var manualAmount = ""
    @State private var selectedCategory = "é¤é¥®"
    @State private var transactionNote = ""
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 20) {
                    // è¯­éŸ³è®°è´¦å¡ç‰‡
                    VStack(spacing: 15) {
                        Image(systemName: voiceManager.isRecording ? "mic.fill" : "mic")
                            .font(.system(size: 60))
                            .foregroundColor(voiceManager.isRecording ? .red : .blue)
                        
                        Text(voiceManager.isRecording ? "æ­£åœ¨å½•éŸ³..." : "ç‚¹å‡»å¼€å§‹è¯­éŸ³è®°è´¦")
                            .font(.headline)
                        
                        if !voiceManager.recognizedText.isEmpty {
                            Text(voiceManager.recognizedText)
                                .padding()
                                .background(Color.gray.opacity(0.1))
                                .cornerRadius(10)
                        }

                        // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
                        if !voiceManager.errorMessage.isEmpty {
                            Text(voiceManager.errorMessage)
                                .foregroundColor(.red)
                                .padding()
                                .background(Color.red.opacity(0.1))
                                .cornerRadius(10)
                        }
                        
                        Button(action: {
                            if voiceManager.isRecording {
                                voiceManager.stopRecording()
                                // è§£æå¹¶æ·»åŠ å¤šç¬”äº¤æ˜“
                                print("ğŸ” å¼€å§‹è§£æè¯­éŸ³æ–‡æœ¬: \"\(voiceManager.recognizedText)\"")
                                let parsedTransactions = voiceManager.parseMultipleTransactions(from: voiceManager.recognizedText)

                                print("ğŸ¯ è§£æç»“æœ: å‘ç° \(parsedTransactions.count) ç¬”äº¤æ˜“")
                                for (idx, tx) in parsedTransactions.enumerated() {
                                    print("  äº¤æ˜“\(idx+1): é‡‘é¢=\(tx.amount ?? 0), åˆ†ç±»=\(tx.category ?? "æœªçŸ¥"), å¤‡æ³¨=\(tx.note ?? "")")
                                }

                                for (index, parsed) in parsedTransactions.enumerated() {
                                    if let amount = parsed.amount {
                                        let transaction = Transaction(
                                            amount: amount,
                                            category: parsed.category ?? "å…¶ä»–",
                                            note: parsed.note ?? "",
                                            date: Date(),
                                            isExpense: true
                                        )
                                        dataManager.addTransaction(transaction)
                                        print("ğŸ’¾ æ·»åŠ ç¬¬ \(index + 1) ç¬”äº¤æ˜“: \(amount)å…ƒ - \(parsed.category ?? "å…¶ä»–")")
                                    }
                                }

                                // æä¾›åé¦ˆ
                                if parsedTransactions.count > 1 {
                                    print("ğŸ‰ æˆåŠŸæ·»åŠ  \(parsedTransactions.count) ç¬”äº¤æ˜“")
                                } else if parsedTransactions.count == 1 {
                                    print("âœ… æˆåŠŸæ·»åŠ  1 ç¬”äº¤æ˜“")
                                } else {
                                    print("âš ï¸ æœªèƒ½è¯†åˆ«åˆ°æœ‰æ•ˆçš„äº¤æ˜“é‡‘é¢")
                                }
                            } else {
                                voiceManager.startRecording()
                            }
                        }) {
                            Text(voiceManager.isRecording ? "åœæ­¢å½•éŸ³" : "å¼€å§‹å½•éŸ³")
                                .font(.headline)
                                .padding()
                                .frame(width: 200)
                                .background(voiceManager.isRecording ? Color.red : Color.blue)
                                .foregroundColor(.white)
                                .cornerRadius(25)
                        }
                    }
                    .padding()
                    .background(Color.gray.opacity(0.1))
                    .cornerRadius(15)
                    
                    // æ‰‹åŠ¨æ·»åŠ æŒ‰é’®
                    Button(action: { showingAddTransaction = true }) {
                        HStack {
                            Image(systemName: "plus.circle.fill")
                            Text("æ‰‹åŠ¨æ·»åŠ è®°è´¦")
                        }
                        .padding()
                        .background(Color.green)
                        .foregroundColor(.white)
                        .cornerRadius(10)
                    }
                    
                    // ä»Šæ—¥æ¦‚è§ˆ
                    TodaySummary()

                    // è¿å‡»æ¿€åŠ±å¡ç‰‡
                    StreakMotivationCard()

                    // æœ€è¿‘äº¤æ˜“
                    RecentTransactions()
                }
                .padding()
            }
            .navigationTitle("è¯­éŸ³è®°è´¦")
            .sheet(isPresented: $showingAddTransaction) {
                AddTransactionView(isPresented: $showingAddTransaction)
            }
        }
    }
}

// MARK: - Today Summary
struct TodaySummary: View {
    @EnvironmentObject var dataManager: DataManager
    
    var todayExpense: Double {
        dataManager.todayTransactions
            .filter { $0.isExpense }
            .reduce(0) { $0 + $1.amount }
    }
    
    var remainingBudget: Double {
        dataManager.budget.monthlyLimit - dataManager.monthlyExpense
    }
    
    var body: some View {
        VStack(alignment: .leading, spacing: 10) {
            Text("ä»Šæ—¥æ¦‚è§ˆ")
                .font(.headline)
            
            HStack(spacing: 8) {
                // ä»Šæ—¥æ”¯å‡º
                VStack(spacing: 4) {
                    Text("ä»Šæ—¥æ”¯å‡º")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                        .minimumScaleFactor(0.8)
                    Text("Â¥\(String(format: "%.1f", todayExpense))")
                        .font(.system(size: 15, weight: .semibold))
                        .foregroundColor(.red)
                        .minimumScaleFactor(0.7)
                        .lineLimit(1)
                }
                .frame(maxWidth: .infinity)
                
                Divider()
                    .frame(height: 30)
                
                // æœ¬æœˆæ”¯å‡º
                VStack(spacing: 4) {
                    Text("æœ¬æœˆæ”¯å‡º")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                        .minimumScaleFactor(0.8)
                    Text("Â¥\(String(format: "%.1f", dataManager.monthlyExpense))")
                        .font(.subheadline)
                        .font(.system(size: 16, weight: .semibold))
                        .foregroundColor(.orange)
                        .minimumScaleFactor(0.7)
                        .lineLimit(1)
                }
                .frame(maxWidth: .infinity)
                
                Divider()
                    .frame(height: 30)
                
                // å‰©ä½™é¢„ç®—
                VStack(spacing: 4) {
                    Text("å‰©ä½™é¢„ç®—")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                        .minimumScaleFactor(0.8)
                    Text("Â¥\(String(format: "%.1f", remainingBudget))")
                        .font(.subheadline)
                        .font(.system(size: 16, weight: .semibold))
                        .foregroundColor(remainingBudget > 0 ? .green : .red)
                        .minimumScaleFactor(0.7)
                        .lineLimit(1)
                }
                .frame(maxWidth: .infinity)

                Divider()
                    .frame(height: 30)

                // è¿å‡»å¤©æ•°
                VStack(spacing: 4) {
                    Text("è¿å‡»å¤©æ•°")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                        .minimumScaleFactor(0.8)
                    HStack(spacing: 2) {
                        Text("ğŸ”¥")
                            .font(.caption)
                        Text("\(dataManager.userStats.currentStreak)")
                            .font(.subheadline)
                            .font(.system(size: 16, weight: .semibold))
                            .foregroundColor(.orange)
                        Text("å¤©")
                            .font(.caption2)
                            .foregroundColor(.secondary)
                    }
                    .minimumScaleFactor(0.7)
                    .lineLimit(1)
                }
                .frame(maxWidth: .infinity)
            }
            .padding(.horizontal, 12)
            .padding(.vertical, 16)
            .background(Color.gray.opacity(0.08))
            .cornerRadius(12)
            .overlay(
                RoundedRectangle(cornerRadius: 12)
                    .stroke(Color.gray.opacity(0.2), lineWidth: 0.5)
            )
        }
    }
}

// MARK: - Streak Motivation Card
struct StreakMotivationCard: View {
    @EnvironmentObject var dataManager: DataManager

    var motivationMessage: String {
        let streak = dataManager.userStats.currentStreak
        switch streak {
        case 0:
            return "ä»Šå¤©å°±å¼€å§‹è®°è´¦å§ï¼ğŸ˜Š"
        case 1:
            return "å¤ªæ£’äº†ï¼ç¬¬ä¸€å¤©å®Œæˆï¼âœ¨"
        case 2:
            return "å¾ˆå¥½ï¼è®°è´¦ä¹ æƒ¯æ­£åœ¨å…»æˆğŸ’ª"
        case 3..<7:
            return "ç»§ç»­åŠ æ²¹ï¼ä½ å·²ç»è¿ç»­\(streak)å¤©äº†ğŸ”¥"
        case 7..<15:
            return "äº†ä¸èµ·ï¼\(streak)å¤©çš„åšæŒçœŸæ£’ğŸ†"
        case 15..<30:
            return "ä¹ æƒ¯å¤§å¸ˆï¼\(streak)å¤©çš„æˆæœä»¤äººæƒŠå¹ğŸ†"
        default:
            return "è®°è´¦ä¹‹ç‹ï¼\(streak)å¤©è¿å‡»æ— äººèƒ½æŒ‘æˆ˜ğŸ‘‘"
        }
    }

    var nextMilestone: Int {
        let streak = dataManager.userStats.currentStreak
        if streak < 3 { return 3 }
        if streak < 7 { return 7 }
        if streak < 15 { return 15 }
        if streak < 30 { return 30 }
        return streak + 10 // è¶…è¿‡30å¤©åï¼Œæ¯10å¤©ä¸ºä¸€ä¸ªé‡Œç¨‹ç¢‘
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Text("è¿å‡»æ¿€åŠ±")
                    .font(.headline)
                Spacer()
                Text("ğŸ†")
                    .font(.title2)
            }

            VStack(alignment: .leading, spacing: 8) {
                Text(motivationMessage)
                    .font(.body)
                    .foregroundColor(.primary)

                if dataManager.userStats.currentStreak > 0 {
                    let progress = Double(dataManager.userStats.currentStreak) / Double(nextMilestone)
                    let remainingDays = nextMilestone - dataManager.userStats.currentStreak

                    VStack(alignment: .leading, spacing: 4) {
                        HStack {
                            Text("è¿å‡»è¿›åº¦")
                                .font(.caption)
                                .foregroundColor(.secondary)
                            Spacer()
                            Text("å†å …æŒ\(remainingDays)å¤©è§£é”ä¸‹ä¸ªæˆå°±")
                                .font(.caption2)
                                .foregroundColor(.blue)
                        }

                        ProgressView(value: progress)
                            .progressViewStyle(LinearProgressViewStyle(tint: .orange))
                            .scaleEffect(y: 1.5)

                        HStack {
                            Text("\(dataManager.userStats.currentStreak)")
                                .font(.caption2)
                                .foregroundColor(.orange)
                                .font(.system(size: 16, weight: .semibold))
                            Spacer()
                            Text("\(nextMilestone)")
                                .font(.caption2)
                                .foregroundColor(.secondary)
                        }
                    }
                }

                if dataManager.userStats.maxStreak > dataManager.userStats.currentStreak {
                    Text("æœ€ä½³è®°å½•ï¼š\(dataManager.userStats.maxStreak)å¤© ğŸ–ï¸")
                        .font(.caption)
                        .foregroundColor(.purple)
                        .font(.system(size: 16, weight: .medium))
                }
            }
        }
        .padding()
        .background(
            LinearGradient(
                gradient: Gradient(colors: [Color.orange.opacity(0.1), Color.yellow.opacity(0.05)]),
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        )
        .cornerRadius(12)
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(Color.orange.opacity(0.3), lineWidth: 1)
        )
    }
}

// MARK: - Recent Transactions
struct RecentTransactions: View {
    @EnvironmentObject var dataManager: DataManager
    
    var recentTransactions: [Transaction] {
        Array(dataManager.transactions.sorted { $0.date > $1.date }.prefix(5))
    }
    
    var body: some View {
        VStack(alignment: .leading, spacing: 10) {
            Text("æœ€è¿‘äº¤æ˜“")
                .font(.headline)
            
            if recentTransactions.isEmpty {
                Text("æš‚æ— äº¤æ˜“è®°å½•")
                    .foregroundColor(.secondary)
                    .padding()
            } else {
                ForEach(recentTransactions) { transaction in
                    TransactionRow(transaction: transaction)
                }
            }
        }
    }
}

// MARK: - Transaction Row
struct TransactionRow: View {
    let transaction: Transaction
    
    var dateFormatter: DateFormatter {
        let formatter = DateFormatter()
        formatter.dateFormat = "MM-dd HH:mm"
        return formatter
    }
    
    var body: some View {
        HStack {
            VStack(alignment: .leading) {
                Text(transaction.category)
                    .font(.headline)
                Text(transaction.note)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .lineLimit(1)
            }
            
            Spacer()
            
            VStack(alignment: .trailing) {
                Text("\(transaction.isExpense ? "-" : "+")Â¥\(String(format: "%.2f", transaction.amount))")
                    .font(.headline)
                    .foregroundColor(transaction.isExpense ? .red : .green)
                Text(dateFormatter.string(from: transaction.date))
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
        .padding()
        .background(Color.gray.opacity(0.05))
        .cornerRadius(10)
    }
}

// MARK: - Add Transaction View
struct AddTransactionView: View {
    @Binding var isPresented: Bool
    @EnvironmentObject var dataManager: DataManager
    
    @State private var amount = ""
    @State private var selectedCategory = "é¤é¥®"
    @State private var note = ""
    @State private var isExpense = true
    @State private var selectedDate = Date()
    
    var body: some View {
        NavigationView {
            Form {
                Section("äº¤æ˜“ä¿¡æ¯") {
                    TextField("é‡‘é¢", text: $amount)
                        .keyboardType(.decimalPad)
                    
                    Picker("ç±»å‹", selection: $isExpense) {
                        Text("æ”¯å‡º").tag(true)
                        Text("æ”¶å…¥").tag(false)
                    }
                    .pickerStyle(SegmentedPickerStyle())
                    
                    Picker("åˆ†ç±»", selection: $selectedCategory) {
                        ForEach(dataManager.categories, id: \.self) { category in
                            Text(category).tag(category)
                        }
                    }
                    
                    TextField("å¤‡æ³¨", text: $note)
                    
                    DatePicker("æ—¥æœŸ", selection: $selectedDate, displayedComponents: [.date, .hourAndMinute])
                }
            }
            .navigationTitle("æ·»åŠ äº¤æ˜“")
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("å–æ¶ˆ") { isPresented = false }
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("ä¿å­˜") {
                        if let amountValue = Double(amount) {
                            let transaction = Transaction(
                                amount: amountValue,
                                category: selectedCategory,
                                note: note,
                                date: selectedDate,
                                isExpense: isExpense
                            )
                            dataManager.addTransaction(transaction)
                            isPresented = false
                        }
                    }
                }
            }
        }
    }
}

// MARK: - Records View
struct RecordsView: View {
    @EnvironmentObject var dataManager: DataManager
    @State private var searchText = ""
    @State private var selectedCategory: String? = nil
    
    var filteredTransactions: [Transaction] {
        var result = dataManager.transactions
        
        if !searchText.isEmpty {
            result = result.filter {
                $0.note.contains(searchText) || $0.category.contains(searchText)
            }
        }
        
        if let category = selectedCategory {
            result = result.filter { $0.category == category }
        }
        
        return result.sorted { $0.date > $1.date }
    }
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 20) {
                    // æœç´¢æ 
                    HStack {
                        Image(systemName: "magnifyingglass")
                            .foregroundColor(.gray)
                        TextField("æœç´¢äº¤æ˜“", text: $searchText)
                            .textFieldStyle(RoundedBorderTextFieldStyle())
                    }
                    .padding(.horizontal)
                    
                    // åˆ†ç±»ç­›é€‰
                    ScrollView(.horizontal, showsIndicators: false) {
                        HStack(spacing: 10) {
                            CategoryFilterButton(
                                title: "å…¨éƒ¨",
                                isSelected: selectedCategory == nil,
                                action: { selectedCategory = nil }
                            )
                            
                            ForEach(dataManager.categories, id: \.self) { category in
                                CategoryFilterButton(
                                    title: category,
                                    isSelected: selectedCategory == category,
                                    action: { selectedCategory = category }
                                )
                            }
                        }
                        .padding(.horizontal)
                    }
                    
                    // ç»Ÿè®¡ä¿¡æ¯
                    if !filteredTransactions.isEmpty {
                        HStack {
                            Text("å…± \(filteredTransactions.count) æ¡è®°å½•")
                                .font(.caption)
                                .foregroundColor(.secondary)
                            Spacer()
                            Text("æ€»è®¡: Â¥\(String(format: "%.2f", filteredTransactions.reduce(0) { $0 + $1.amount })))")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                        .padding()
                        .background(Color.gray.opacity(0.1))
                        .cornerRadius(10)
                        .padding(.horizontal)
                    }
                    
                    // äº¤æ˜“è®°å½•åˆ—è¡¨
                    if filteredTransactions.isEmpty {
                        // ç©ºçŠ¶æ€
                        VStack(spacing: 20) {
                            Image(systemName: "tray")
                                .font(.system(size: 50))
                                .foregroundColor(.gray.opacity(0.5))
                            Text("æš‚æ— äº¤æ˜“è®°å½•")
                                .font(.headline)
                                .foregroundColor(.gray)
                            Text("å¼€å§‹è¯­éŸ³è®°è´¦æˆ–æ‰‹åŠ¨æ·»åŠ äº¤æ˜“")
                                .font(.subheadline)
                                .foregroundColor(.gray)
                                .multilineTextAlignment(.center)
                        }
                        .padding(.top, 50)
                    } else {
                        // æ˜¾ç¤ºæ‰€æœ‰äº¤æ˜“è®°å½•
                        ForEach(filteredTransactions) { transaction in
                            SimpleTransactionRow(transaction: transaction)
                                .padding(.horizontal)
                                .onTapGesture {
                                    // é¢„ç•™ï¼šç‚¹å‡»æŸ¥çœ‹è¯¦æƒ…
                                }
                        }
                    }
                    
                    // åº•éƒ¨é—´è·
                    Spacer(minLength: 100)
                }
                .padding(.top)
            }
            .navigationTitle("äº¤æ˜“è®°å½•")
        }
    }
}

// MARK: - Simple Transaction Row
struct SimpleTransactionRow: View {
    let transaction: Transaction
    @EnvironmentObject var dataManager: DataManager
    @State private var showingDeleteAlert = false
    
    private var categoryIcon: String {
        switch transaction.category {
        case "é¤é¥®": return "fork.knife"
        case "äº¤é€š": return "car.fill"
        case "è´­ç‰©": return "bag.fill"
        case "å¨±ä¹": return "gamecontroller.fill"
        case "ç”Ÿæ´»": return "house.fill"
        case "åŒ»ç–—": return "cross.case.fill"
        case "æ•™è‚²": return "book.fill"
        default: return "ellipsis.circle.fill"
        }
    }
    
    private var categoryColor: Color {
        switch transaction.category {
        case "é¤é¥®": return .orange
        case "äº¤é€š": return .blue
        case "è´­ç‰©": return .green
        case "å¨±ä¹": return .purple
        case "ç”Ÿæ´»": return Color(red: 0.6, green: 0.4, blue: 0.2)
        case "åŒ»ç–—": return .red
        case "æ•™è‚²": return Color(red: 0.0, green: 0.7, blue: 1.0)
        default: return .gray
        }
    }
    
    var body: some View {
        HStack {
            // åˆ†ç±»å›¾æ ‡
            Image(systemName: categoryIcon)
                .font(.title2)
                .foregroundColor(categoryColor)
                .frame(width: 40, height: 40)
                .background(categoryColor.opacity(0.1))
                .clipShape(Circle())
            
            // äº¤æ˜“ä¿¡æ¯
            VStack(alignment: .leading, spacing: 4) {
                Text(transaction.category)
                    .font(.headline)
                Text(transaction.note)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .lineLimit(1)
                Text(DateFormatter.transactionDisplay.string(from: transaction.date))
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
            
            Spacer()
            
            // é‡‘é¢
            Text("Â¥\(String(format: "%.2f", transaction.amount))")
                .font(.headline)
                .font(.system(size: 16, weight: .semibold))
                .foregroundColor(categoryColor)
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(10)
        .shadow(color: .gray.opacity(0.2), radius: 5, x: 0, y: 2)
        .contextMenu {
            Button(action: {
                dataManager.deleteTransaction(transaction)
            }) {
                Label("åˆ é™¤", systemImage: "trash")
            }
        }
    }
}

// MARK: - Date Formatter Extension
extension DateFormatter {
    static let transactionDisplay: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMæœˆddæ—¥ HH:mm"
        formatter.locale = Locale(identifier: "zh_CN")
        return formatter
    }()
}



// MARK: - Category Filter Button
struct CategoryFilterButton: View {
    let title: String
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            Text(title)
                .padding(.horizontal, 15)
                .padding(.vertical, 8)
                .background(isSelected ? Color.blue : Color.gray.opacity(0.2))
                .foregroundColor(isSelected ? .white : .primary)
                .cornerRadius(15)
        }
    }
}

// MARK: - Budget View
struct BudgetView: View {
    @EnvironmentObject var dataManager: DataManager
    @State private var editingBudget = false
    @State private var newMonthlyLimit = ""
    
    var budgetProgress: Double {
        min(dataManager.monthlyExpense / dataManager.budget.monthlyLimit, 1.0)
    }
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 20) {
                    // æœˆåº¦é¢„ç®—
                    VStack(spacing: 15) {
                        HStack {
                            VStack(alignment: .leading, spacing: 4) {
                                Text("æœ¬æœˆé¢„ç®—")
                                    .font(.headline)
                                Text("(åˆ†ç±»é¢„ç®—è‡ªåŠ¨æ±‡æ€»)")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                            Spacer()
                            Button("è®¾ç½®åˆ†ç±»é¢„ç®—") { editingBudget = true }
                                .font(.subheadline)
                        }
                        
                        Text("Â¥\(String(format: "%.0f", dataManager.budget.monthlyLimit))")
                            .font(.largeTitle)
                            .font(.system(size: 18, weight: .bold))
                            .foregroundColor(.blue)
                        
                        ProgressView(value: budgetProgress)
                            .progressViewStyle(LinearProgressViewStyle(tint: budgetProgress > 0.8 ? .red : .blue))
                        
                        HStack {
                            VStack {
                                Text("å·²ç”¨")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                                Text("Â¥\(String(format: "%.2f", dataManager.monthlyExpense))")
                                    .font(.system(size: 16, weight: .semibold))
                                    .foregroundColor(.red)
                            }
                            
                            Spacer()
                            
                            VStack {
                                Text("å‰©ä½™")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                                Text("Â¥\(String(format: "%.2f", dataManager.budget.monthlyLimit - dataManager.monthlyExpense))")
                                    .font(.system(size: 16, weight: .semibold))
                                    .foregroundColor(.green)
                            }
                            
                            Spacer()
                            
                            VStack {
                                Text("ä½¿ç”¨ç‡")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                                Text("\(Int(budgetProgress * 100))%")
                                    .font(.system(size: 16, weight: .semibold))
                                    .foregroundColor(.orange)
                            }
                        }
                    }
                    .padding()
                    .background(Color.gray.opacity(0.1))
                    .cornerRadius(15)
                    
                    // åˆ†ç±»é¢„ç®—
                    VStack(alignment: .leading, spacing: 15) {
                        Text("åˆ†ç±»é¢„ç®—")
                            .font(.headline)
                        
                        ForEach(dataManager.categories, id: \.self) { category in
                            let limit = dataManager.budget.categoryLimits[category] ?? 0
                            CategoryBudgetRow(
                                category: category,
                                limit: limit,
                                used: dataManager.getCategoryExpense(category: category)
                            )
                        }
                    }
                    .padding()
                    .background(Color.gray.opacity(0.1))
                    .cornerRadius(15)
                }
                .padding()
            }
            .navigationTitle("é¢„ç®—ç®¡ç†")
            .sheet(isPresented: $editingBudget) {
                EditBudgetView(isPresented: $editingBudget)
            }
        }
    }
}

// MARK: - Category Budget Row
struct CategoryBudgetRow: View {
    let category: String
    let limit: Double
    let used: Double
    
    var progress: Double {
        limit > 0 ? min(used / limit, 1.0) : 0
    }
    
    var progressColor: Color {
        if progress > 0.9 { return .red }
        if progress > 0.7 { return .orange }
        return .blue
    }
    
    var body: some View {
        VStack(spacing: 8) {
            HStack {
                Text(category)
                    .font(.system(size: 16, weight: .medium))
                Spacer()
                if limit > 0 {
                    VStack(alignment: .trailing, spacing: 2) {
                        Text("Â¥\(String(format: "%.0f", used)) / Â¥\(String(format: "%.0f", limit))")
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                        Text("\(Int(progress * 100))%")
                            .font(.system(size: 12, weight: .medium))
                            .foregroundColor(progressColor)
                    }
                } else {
                    VStack(alignment: .trailing, spacing: 2) {
                        Text("æœªè®¾ç½®é¢„ç®—")
                            .font(.caption)
                            .foregroundColor(.orange)
                            .italic()
                        Text("0%")
                            .font(.caption)
                            .foregroundColor(.gray)
                    }
                }
            }
            
            if limit > 0 {
                ProgressView(value: progress)
                    .progressViewStyle(LinearProgressViewStyle(tint: progressColor))
            } else {
                Rectangle()
                    .fill(Color.gray.opacity(0.2))
                    .frame(height: 6)
                    .cornerRadius(3)
                    .overlay(
                        Text("ç‚¹å‡»è®¾ç½®é¢„ç®—ä»¥å¯ç”¨è¿›åº¦è·Ÿè¸ª")
                            .font(.caption2)
                            .foregroundColor(.gray)
                    )
            }
        }
    }
}

// MARK: - Edit Budget View
struct EditBudgetView: View {
    @Binding var isPresented: Bool
    @EnvironmentObject var dataManager: DataManager
    @State private var categoryLimits: [String: String] = [:]
    
    // è®¡ç®—åˆ†ç±»é¢„ç®—æ€»å’Œ
    var calculatedTotalBudget: Double {
        return categoryLimits.compactMap { Double($0.value) }.reduce(0, +)
    }
    
    var body: some View {
        NavigationView {
            Form {
                Section("åˆ†ç±»é¢„ç®—è®¾ç½®") {
                    ForEach(dataManager.categories, id: \.self) { category in
                        HStack {
                            Text(category)
                                .font(.subheadline)
                            Spacer()
                            TextField("0", text: Binding(
                                get: { categoryLimits[category] ?? "" },
                                set: { categoryLimits[category] = $0 }
                            ))
                            .keyboardType(.decimalPad)
                            .multilineTextAlignment(.trailing)
                            .textFieldStyle(RoundedBorderTextFieldStyle())
                            .frame(width: 80)
                            Text("å…ƒ")
                                .foregroundColor(.secondary)
                                .font(.caption)
                        }
                    }
                }
                
                Section("é¢„ç®—æ±‡æ€»") {
                    HStack {
                        Text("æœˆåº¦æ€»é¢„ç®—")
                            .font(.headline)
                        Spacer()
                        Text("Â¥\(String(format: "%.0f", calculatedTotalBudget))")
                            .font(.title2)
                            .font(.system(size: 18, weight: .bold))
                            .foregroundColor(.blue)
                    }
                    .padding(.vertical, 8)
                    
                    if calculatedTotalBudget == 0 {
                        Text("è¯·è®¾ç½®å„åˆ†ç±»é¢„ç®—")
                            .font(.caption)
                            .foregroundColor(.secondary)
                            .italic()
                    } else {
                        Text("å„åˆ†ç±»é¢„ç®—è‡ªåŠ¨ç´¯è®¡ä¸ºæœˆåº¦æ€»é¢„ç®—")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
                
                Section("å¿«é€Ÿè®¾ç½®") {
                    VStack(spacing: 12) {
                        Text("æ¨èé¢„ç®—åˆ†é…ï¼ˆåŸºäºÂ¥3000æ€»é¢„ç®—ï¼‰")
                            .font(.caption)
                            .foregroundColor(.secondary)
                        
                        Button("åº”ç”¨æ¨èåˆ†é…") {
                            categoryLimits = [
                                "é¤é¥®": "900",  // 30%
                                "äº¤é€š": "450",  // 15%
                                "è´­ç‰©": "600",  // 20%
                                "å¨±ä¹": "300",  // 10%
                                "ç”Ÿæ´»": "450",  // 15%
                                "åŒ»ç–—": "150",  // 5%
                                "æ•™è‚²": "120",  // 4%
                                "å…¶ä»–": "30"    // 1%
                            ]
                        }
                        .foregroundColor(.blue)
                    }
                    .padding(.vertical, 8)
                }
            }
            .navigationTitle("é¢„ç®—è®¾ç½®")
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("å–æ¶ˆ") { isPresented = false }
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("ä¿å­˜") {
                        // ä¿å­˜åˆ†ç±»é¢„ç®—
                        for (category, limitStr) in categoryLimits {
                            if let limit = Double(limitStr), limit > 0 {
                                dataManager.budget.categoryLimits[category] = limit
                            } else {
                                dataManager.budget.categoryLimits[category] = 0
                            }
                        }

                        // æ¸…ç†ä¸å­˜åœ¨çš„åˆ†ç±»é¢„ç®—
                        let validCategories = Set(dataManager.categories)
                        dataManager.budget.categoryLimits = dataManager.budget.categoryLimits.filter { validCategories.contains($0.key) }

                        // è‡ªåŠ¨è®¡ç®—å¹¶è®¾ç½®æœˆåº¦æ€»é¢„ç®—
                        dataManager.budget.monthlyLimit = calculatedTotalBudget

                        // ä¿å­˜æ•°æ®åˆ°æœ¬åœ°
                        dataManager.saveData()

                        isPresented = false
                    }
                }
            }
        }
        .onAppear {
            // åˆå§‹åŒ–åˆ†ç±»é¢„ç®—æ•°æ®
            for category in dataManager.categories {
                let limit = dataManager.budget.categoryLimits[category] ?? 0
                categoryLimits[category] = limit > 0 ? "\(Int(limit))" : ""
            }
        }
    }
}

// MARK: - Analytics View
struct AnalyticsView: View {
    @EnvironmentObject var dataManager: DataManager
    
    var categoryExpenses: [(String, Double)] {
        dataManager.categories.map { category in
            (category, dataManager.getCategoryExpense(category: category))
        }.filter { $0.1 > 0 }
    }
    
    var totalExpense: Double {
        categoryExpenses.reduce(0) { $0 + $1.1 }
    }
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 20) {
                    // æœˆåº¦æ€»è§ˆ
                    VStack(spacing: 15) {
                        Text("æœ¬æœˆæ”¯å‡º")
                            .font(.headline)
                        
                        Text("Â¥\(String(format: "%.2f", dataManager.monthlyExpense))")
                            .font(.largeTitle)
                            .font(.system(size: 18, weight: .bold))
                            .foregroundColor(.red)
                        
                        HStack {
                            VStack {
                                Text("æ—¥å‡æ”¯å‡º")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                                Text("Â¥\(String(format: "%.2f", dataManager.monthlyExpense / Double(Calendar.current.component(.day, from: Date()))))")
                                    .font(.system(size: 16, weight: .semibold))
                            }
                            
                            Spacer()
                            
                            VStack {
                                Text("äº¤æ˜“ç¬”æ•°")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                                Text("\(dataManager.transactions.filter { $0.isExpense }.count)")
                                    .font(.system(size: 16, weight: .semibold))
                            }
                        }
                    }
                    .padding()
                    .background(Color.gray.opacity(0.1))
                    .cornerRadius(15)
                    
                    // åˆ†ç±»ç»Ÿè®¡
                    VStack(alignment: .leading, spacing: 15) {
                        Text("åˆ†ç±»æ”¯å‡º")
                            .font(.headline)
                        
                        ForEach(categoryExpenses.sorted { $0.1 > $1.1 }, id: \.0) { category, expense in
                            HStack {
                                Text(category)
                                    .font(.system(size: 16, weight: .medium))
                                
                                Spacer()
                                
                                VStack(alignment: .trailing) {
                                    Text("Â¥\(String(format: "%.2f", expense))")
                                        .font(.system(size: 16, weight: .semibold))
                                    Text("\(Int((expense / totalExpense) * 100))%")
                                        .font(.caption)
                                        .foregroundColor(.secondary)
                                }
                            }
                            .padding(.vertical, 5)
                        }
                    }
                    .padding()
                    .background(Color.gray.opacity(0.1))
                    .cornerRadius(15)
                }
                .padding()
            }
            .navigationTitle("æ•°æ®ç»Ÿè®¡")
        }
    }
}

// MARK: - Settings View
struct SettingsView: View {
    @EnvironmentObject var dataManager: DataManager
    @AppStorage("voiceEnabled") private var voiceEnabled = true
    @AppStorage("budgetReminder") private var budgetReminder = true
    @AppStorage("hasCompletedOnboarding") private var hasCompletedOnboarding = true
    @State private var showingClearAlert = false
    @State private var showingCategoryManager = false
    @State private var showOnboarding = false
    
    var body: some View {
        NavigationView {
            List {
                Section("è¯­éŸ³è®¾ç½®") {
                    Toggle("å¯ç”¨è¯­éŸ³è¯†åˆ«", isOn: $voiceEnabled)
                }
                
                Section("é¢„ç®—è®¾ç½®") {
                    Toggle("é¢„ç®—æé†’", isOn: $budgetReminder)
                }

                Section("é€šçŸ¥è®¾ç½®") {
                    NavigationLink(destination: NotificationSettingsView()) {
                        HStack {
                            Image(systemName: "bell.fill")
                                .foregroundColor(.red)
                            VStack(alignment: .leading) {
                                Text("æé†’é€šçŸ¥")
                                Text(dataManager.appSettings.notificationsEnabled ? "å·²å¼€å¯" : "å·²å…³é—­")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                        }
                    }
                }

                Section("åº”ç”¨å¼•å¯¼") {
                    Button(action: {
                        showOnboarding = true
                    }) {
                        HStack {
                            Image(systemName: "questionmark.circle.fill")
                                .foregroundColor(.blue)
                            Text("é‡æ–°æ˜¾ç¤ºä½¿ç”¨å¼•å¯¼")
                                .foregroundColor(.primary)
                            Spacer()
                            Image(systemName: "chevron.right")
                                .foregroundColor(.gray)
                                .font(.caption)
                        }
                    }
                }

                Section("æˆå°±ç³»ç»Ÿ") {
                    NavigationLink(destination: AchievementView()) {
                        HStack {
                            Image(systemName: "trophy.fill")
                                .foregroundColor(.orange)
                            VStack(alignment: .leading) {
                                Text("æˆå°±å¾½ç« ")
                                Text("å·²è§£é” \(dataManager.achievements.filter { $0.isUnlocked }.count)/\(dataManager.achievements.count)")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                            Spacer()
                            if dataManager.userStats.currentStreak > 0 {
                                VStack {
                                    Text("ğŸ”¥")
                                    Text("\(dataManager.userStats.currentStreak)")
                                        .font(.caption)
                                        .font(.system(size: 18, weight: .bold))
                                }
                            }
                        }
                    }
                }
                
                Section("åˆ†ç±»ç®¡ç†") {
                    NavigationLink(destination: CategoryManagerView()) {
                        HStack {
                            Image(systemName: "folder.fill")
                                .foregroundColor(.blue)
                            Text("ç®¡ç†åˆ†ç±»")
                        }
                    }
                    
                    HStack {
                        Text("å½“å‰åˆ†ç±»æ•°")
                        Spacer()
                        Text("\(dataManager.categories.count)")
                            .foregroundColor(.secondary)
                    }
                }
                
                Section("æ•°æ®ç®¡ç†") {
                    NavigationLink(destination: ExportDataView()) {
                        HStack {
                            Image(systemName: "square.and.arrow.up")
                                .foregroundColor(.blue)
                            VStack(alignment: .leading) {
                                Text("æ•°æ®å¯¼å‡º")
                                Text("å¯¼å‡ºè®°è´¦æ•°æ®ä¸º CSV æˆ–æ–‡æœ¬æ ¼å¼")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                        }
                    }

                    Button(action: { showingClearAlert = true }) {
                        Text("æ¸…ç©ºæ‰€æœ‰æ•°æ®")
                            .foregroundColor(.red)
                    }
                }
                
                Section("å…³äº") {
                    HStack {
                        Text("ç‰ˆæœ¬")
                        Spacer()
                        VStack(alignment: .trailing) {
                            Text("1.0.6")
                                .foregroundColor(.secondary)
                            Text("åŠŸèƒ½å®Œæ•´ç‰ˆ")
                                .font(.caption2)
                                .foregroundColor(.blue)
                        }
                    }
                    
                    HStack {
                        Text("è®°å½•æ€»æ•°")
                        Spacer()
                        Text("\(dataManager.transactions.count)")
                            .foregroundColor(.secondary)
                    }
                    
                    HStack {
                        Text("åˆ†ç±»æ•°é‡")
                        Spacer()
                        Text("\(dataManager.categories.count)")
                            .foregroundColor(.secondary)
                    }
                    
                    HStack {
                        Text("æ”¯æŒç³»ç»Ÿ")
                        Spacer()
                        Text("iOS 14.0+")
                            .foregroundColor(.secondary)
                    }
                }
            }
            .navigationTitle("è®¾ç½®")
            .alert(isPresented: $showingClearAlert) {
                Alert(
                    title: Text("æ¸…ç©ºæ•°æ®"),
                    message: Text("ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰äº¤æ˜“è®°å½•å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚"),
                    primaryButton: .destructive(Text("æ¸…ç©º")) {
                        dataManager.transactions.removeAll()
                    },
                    secondaryButton: .cancel(Text("å–æ¶ˆ"))
                )
            }
            .sheet(isPresented: $showOnboarding) {
                OnboardingView(showOnboarding: $showOnboarding)
            }
        }
    }
}

// MARK: - Category Manager View
struct CategoryManagerView: View {
    @EnvironmentObject var dataManager: DataManager
    @Environment(\.presentationMode) var presentationMode
    @State private var newCategoryName = ""
    @State private var showingDeleteAlert = false
    @State private var selectedCategory = ""
    @State private var editingCategory: String? = nil
    @State private var editingCategoryName = ""
    
    var body: some View {
        List {
            Section("æ·»åŠ æ–°åˆ†ç±»") {
                HStack {
                    TextField("è¾“å…¥åˆ†ç±»åç§°", text: $newCategoryName)
                    Button("æ·»åŠ ") {
                        if !newCategoryName.isEmpty {
                            dataManager.addCategory(newCategoryName)
                            newCategoryName = ""
                        }
                    }
                    .disabled(newCategoryName.isEmpty)
                }
            }
            
            Section("å½“å‰åˆ†ç±»") {
                ForEach(dataManager.categories, id: \.self) { category in
                    HStack {
                        if editingCategory == category {
                            TextField("åˆ†ç±»åç§°", text: $editingCategoryName)
                                .textFieldStyle(RoundedBorderTextFieldStyle())
                        } else {
                            Text(category)
                                .font(.subheadline)
                        }
                        
                        Spacer()
                        
                        // æ˜¾ç¤ºä½¿ç”¨æ­¤åˆ†ç±»çš„äº¤æ˜“æ•°é‡
                        let transactionCount = dataManager.transactions.filter { $0.category == category }.count
                        if transactionCount > 0 {
                            Text("\(transactionCount)æ¡è®°å½•")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                        
                        if editingCategory == category {
                            Button("ä¿å­˜") {
                                if !editingCategoryName.isEmpty && editingCategoryName != category {
                                    dataManager.updateCategory(oldName: category, newName: editingCategoryName)
                                }
                                editingCategory = nil
                            }
                            .foregroundColor(.green)
                            .font(.caption)
                            
                            Button("å–æ¶ˆ") {
                                editingCategory = nil
                            }
                            .foregroundColor(.red)
                            .font(.caption)
                        } else {
                            Button("ç¼–è¾‘") {
                                editingCategory = category
                                editingCategoryName = category
                            }
                            .foregroundColor(.blue)
                            .font(.caption)
                        }
                    }
                    .contextMenu {
                        Button("é‡å‘½å") {
                            editingCategory = category
                            editingCategoryName = category
                        }
                        
                        Button("åˆ é™¤") {
                            selectedCategory = category
                            showingDeleteAlert = true
                        }
                        .foregroundColor(.red)
                    }
                }
            }
            
            Section("ä½¿ç”¨è¯´æ˜") {
                VStack(alignment: .leading, spacing: 8) {
                    Text("â€¢ ç‚¹å‡»'ç¼–è¾‘'å¯ç›´æ¥ä¿®æ”¹åˆ†ç±»å")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text("â€¢ é•¿æŒ‰åˆ†ç±»å¯æ˜¾ç¤ºå¿«æ·èœå•")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text("â€¢ æœ‰äº¤æ˜“è®°å½•çš„åˆ†ç±»ä¸èƒ½åˆ é™¤")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text("â€¢ é‡å‘½åä¼šè‡ªåŠ¨æ›´æ–°æ‰€æœ‰è®°å½•")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                .padding(.vertical, 4)
            }
        }
        .navigationTitle("åˆ†ç±»ç®¡ç†")
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Button("å®Œæˆ") {
                    editingCategory = nil // é€€å‡ºç¼–è¾‘çŠ¶æ€
                    presentationMode.wrappedValue.dismiss() // è¿”å›ä¸Šä¸€é¡µ
                }
            }
        }
        .alert(isPresented: $showingDeleteAlert) {
            let hasTransactions = dataManager.transactions.contains { $0.category == selectedCategory }
            if hasTransactions {
                return Alert(
                    title: Text("åˆ é™¤åˆ†ç±»"),
                    message: Text("æ­¤åˆ†ç±»è¿˜æœ‰äº¤æ˜“è®°å½•ï¼Œæ— æ³•åˆ é™¤ã€‚è¯·å…ˆåˆ é™¤æˆ–ä¿®æ”¹ç›¸å…³äº¤æ˜“ã€‚"),
                    dismissButton: .default(Text("ç¡®å®š"))
                )
            } else {
                return Alert(
                    title: Text("åˆ é™¤åˆ†ç±»"),
                    message: Text("ç¡®å®šè¦åˆ é™¤åˆ†ç±»'\(selectedCategory)'å—ï¼Ÿ"),
                    primaryButton: .destructive(Text("åˆ é™¤")) {
                        dataManager.deleteCategory(selectedCategory)
                    },
                    secondaryButton: .cancel(Text("å–æ¶ˆ"))
                )
            }
        }
    }
}

// MARK: - Notification Settings View
struct NotificationSettingsView: View {
    @EnvironmentObject var dataManager: DataManager
    @State private var showingPermissionAlert = false

    var body: some View {
        NavigationView {
            List {
                Section("é€šçŸ¥æƒé™") {
                    HStack {
                        Text("é€šçŸ¥æƒé™")
                        Spacer()
                        Button(dataManager.appSettings.notificationsEnabled ? "å·²æˆæƒ" : "è¯·æ±‚æˆæƒ") {
                            if !dataManager.appSettings.notificationsEnabled {
                                requestNotificationPermission()
                            }
                        }
                        .foregroundColor(dataManager.appSettings.notificationsEnabled ? .green : .blue)
                    }

                    Text("è¯·å…è®¸ VoiceBudget å‘é€é€šçŸ¥ï¼Œä»¥ä¾¿æé†’æ‚¨è®°è´¦å’Œé¢„ç®—ç®¡ç†")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }

                if dataManager.appSettings.notificationsEnabled {
                    Section("è®°è´¦æé†’") {
                        Toggle("ä¸Šåˆæé†’", isOn: Binding(
                            get: { dataManager.appSettings.morningReminderEnabled },
                            set: { newValue in
                                dataManager.appSettings.morningReminderEnabled = newValue
                                updateReminders()
                                dataManager.saveData()
                            }
                        ))

                        if dataManager.appSettings.morningReminderEnabled {
                            HStack {
                                Text("ä¸Šåˆæ—¶é—´")
                                Spacer()
                                Text(dataManager.appSettings.morningReminderTime)
                                    .foregroundColor(.secondary)
                            }
                        }

                        Toggle("ä¸‹åˆæé†’", isOn: Binding(
                            get: { dataManager.appSettings.afternoonReminderEnabled },
                            set: { newValue in
                                dataManager.appSettings.afternoonReminderEnabled = newValue
                                updateReminders()
                                dataManager.saveData()
                            }
                        ))

                        if dataManager.appSettings.afternoonReminderEnabled {
                            HStack {
                                Text("ä¸‹åˆæ—¶é—´")
                                Spacer()
                                Text(dataManager.appSettings.afternoonReminderTime)
                                    .foregroundColor(.secondary)
                            }
                        }

                        Toggle("æ™šä¸Šæé†’", isOn: Binding(
                            get: { dataManager.appSettings.eveningReminderEnabled },
                            set: { newValue in
                                dataManager.appSettings.eveningReminderEnabled = newValue
                                updateReminders()
                                dataManager.saveData()
                            }
                        ))

                        if dataManager.appSettings.eveningReminderEnabled {
                            HStack {
                                Text("æ™šä¸Šæ—¶é—´")
                                Spacer()
                                Text(dataManager.appSettings.eveningReminderTime)
                                    .foregroundColor(.secondary)
                            }
                        }
                    }

                    Section("é¢„ç®—è­¦å‘Š") {
                        Toggle("é¢„ç®—è­¦å‘Šé€šçŸ¥", isOn: Binding(
                            get: { dataManager.appSettings.budgetWarningEnabled },
                            set: { newValue in
                                dataManager.appSettings.budgetWarningEnabled = newValue
                                dataManager.saveData()
                            }
                        ))

                        Text("å½“æ”¯å‡ºè¾¾åˆ°é¢„ç®—70%å’Œ90%æ—¶ï¼Œä¼šå‘é€æé†’é€šçŸ¥")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }

                    Section("å…¶ä»–é€šçŸ¥") {
                        Toggle("å‘¨æŠ¥é€šçŸ¥", isOn: Binding(
                            get: { dataManager.appSettings.weeklyReportEnabled },
                            set: { newValue in
                                dataManager.appSettings.weeklyReportEnabled = newValue
                                if newValue {
                                    // è®¡ç®—æœ¬å‘¨æ”¯å‡ºå¹¶è®¾ç½®é€šçŸ¥
                                    let weeklyExpense = calculateWeeklyExpense()
                                    NotificationManager.shared.scheduleWeeklyReport(totalExpense: weeklyExpense)
                                }
                                dataManager.saveData()
                            }
                        ))

                        Text("æ¯å‘¨æ—¥æ™šä¸Š8ç‚¹å‘é€å‘¨æ”¯å‡ºæŠ¥å‘Š")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
            }
            .navigationTitle("é€šçŸ¥è®¾ç½®")
            .onAppear {
                checkNotificationStatus()
            }
            .alert(isPresented: $showingPermissionAlert) {
                Alert(
                    title: Text("é€šçŸ¥æƒé™"),
                    message: Text("è¯·åœ¨è®¾ç½®ä¸­å…è®¸ VoiceBudget å‘é€é€šçŸ¥"),
                    dismissButton: .default(Text("å¥½çš„"))
                )
            }
        }
    }

    private func requestNotificationPermission() {
        NotificationManager.shared.requestAuthorization { granted in
            dataManager.appSettings.notificationsEnabled = granted
            dataManager.saveData()

            if granted {
                updateReminders()
            } else {
                showingPermissionAlert = true
            }
        }
    }

    private func checkNotificationStatus() {
        NotificationManager.shared.checkNotificationStatus { authorized in
            dataManager.appSettings.notificationsEnabled = authorized
            dataManager.saveData()
        }
    }

    private func updateReminders() {
        guard dataManager.appSettings.notificationsEnabled else { return }

        let morningTime = dataManager.appSettings.morningReminderEnabled ? dataManager.appSettings.morningReminderTime : ""
        let afternoonTime = dataManager.appSettings.afternoonReminderEnabled ? dataManager.appSettings.afternoonReminderTime : ""
        let eveningTime = dataManager.appSettings.eveningReminderEnabled ? dataManager.appSettings.eveningReminderTime : ""

        NotificationManager.shared.scheduleReminders(
            morningTime: morningTime,
            afternoonTime: afternoonTime,
            eveningTime: eveningTime
        )
    }

    private func calculateWeeklyExpense() -> Double {
        let calendar = Calendar.current
        let now = Date()
        let weekAgo = calendar.date(byAdding: .day, value: -7, to: now) ?? now

        return dataManager.transactions
            .filter { $0.date >= weekAgo && $0.isExpense }
            .reduce(0) { $0 + $1.amount }
    }
}

// MARK: - Achievement View
struct AchievementView: View {
    @EnvironmentObject var dataManager: DataManager

    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 20) {
                    // ç»Ÿè®¡å¡ç‰‡
                    VStack(spacing: 12) {
                        HStack {
                            VStack(alignment: .leading) {
                                Text("å½“å‰è¿å‡»")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                                Text("\(dataManager.userStats.currentStreak) å¤©")
                                    .font(.title2)
                                    .font(.system(size: 18, weight: .bold))
                                    .foregroundColor(.orange)
                            }

                            Spacer()

                            VStack(alignment: .trailing) {
                                Text("æœ€é•¿è¿å‡»")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                                Text("\(dataManager.userStats.maxStreak) å¤©")
                                    .font(.title2)
                                    .font(.system(size: 18, weight: .bold))
                                    .foregroundColor(.blue)
                            }
                        }

                        Divider()

                        HStack {
                            VStack(alignment: .leading) {
                                Text("æ€»è®°è´¦æ¬¡æ•°")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                                Text("\(dataManager.userStats.totalTransactions)")
                                    .font(.title2)
                                    .font(.system(size: 18, weight: .bold))
                                    .foregroundColor(.green)
                            }

                            Spacer()

                            VStack(alignment: .trailing) {
                                Text("å·²è§£é”æˆå°±")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                                Text("\(dataManager.achievements.filter { $0.isUnlocked }.count)/\(dataManager.achievements.count)")
                                    .font(.title2)
                                    .font(.system(size: 18, weight: .bold))
                                    .foregroundColor(.purple)
                            }
                        }
                    }
                    .padding()
                    .background(Color(.systemGray6))
                    .cornerRadius(12)
                    .padding(.horizontal)

                    // æˆå°±åˆ—è¡¨
                    LazyVGrid(columns: Array(repeating: GridItem(.flexible()), count: 2), spacing: 16) {
                        ForEach(dataManager.achievements) { achievement in
                            AchievementCard(achievement: achievement)
                        }
                    }
                    .padding(.horizontal)
                }
            }
            .navigationTitle("æˆå°±å¾½ç« ")
            .alert(isPresented: $dataManager.showAchievementAlert) {
                if let achievement = dataManager.newAchievement {
                    return Alert(
                        title: Text("ğŸ† æˆå°±è§£é”ï¼"),
                        message: Text("æ­å–œæ‚¨è·å¾—\"\(achievement.name)\"æˆå°±ï¼\n\(achievement.description)"),
                        dismissButton: .default(Text("å¤ªæ£’äº†ï¼"))
                    )
                } else {
                    return Alert(title: Text("æˆå°±è§£é”"))
                }
            }
        }
    }
}

struct AchievementCard: View {
    let achievement: Achievement

    var body: some View {
        VStack(spacing: 8) {
            Text(achievement.icon)
                .font(.system(size: 40))
                .opacity(achievement.isUnlocked ? 1.0 : 0.3)

            Text(achievement.name)
                .font(.headline)
                .foregroundColor(achievement.isUnlocked ? .primary : .secondary)

            Text(achievement.description)
                .font(.caption)
                .multilineTextAlignment(.center)
                .foregroundColor(.secondary)
                .lineLimit(2)

            if achievement.isUnlocked, let unlockedAt = achievement.unlockedAt {
                Text("è§£é”æ—¥æœŸ")
                    .font(.caption2)
                    .foregroundColor(.secondary)
                Text(DateFormatter.short.string(from: unlockedAt))
                    .font(.caption2)
                    .foregroundColor(.blue)
            } else {
                Text("æœªè§£é”")
                    .font(.caption2)
                    .foregroundColor(.secondary)
                    .padding(.vertical, 2)
            }
        }
        .padding()
        .frame(maxWidth: .infinity, minHeight: 140)
        .background(achievement.isUnlocked ? Color.blue.opacity(0.1) : Color(.systemGray6))
        .cornerRadius(12)
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(achievement.isUnlocked ? Color.blue.opacity(0.3) : Color.clear, lineWidth: 2)
        )
        .scaleEffect(achievement.isUnlocked ? 1.0 : 0.95)
        .animation(.easeInOut(duration: 0.2), value: achievement.isUnlocked)
    }
}

// MARK: - Extensions
extension DateFormatter {
    static let short: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        formatter.locale = Locale(identifier: "zh_CN")
        return formatter
    }()
}

// MARK: - Export Data View
struct ExportDataView: View {
    @EnvironmentObject var dataManager: DataManager
    @State private var selectedDateRange: ExportData.DateRange = .thisMonth
    @State private var selectedFormat: ExportData.ExportFormat = .csv
    @State private var showingActivityView = false
    @State private var exportedFileURL: URL?
    @State private var previewData: String = ""
    @State private var showingPreview = false

    var filteredTransactions: [Transaction] {
        dataManager.getTransactionsForExport(dateRange: selectedDateRange)
    }

    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 20) {
                    // æ•°æ®ç»Ÿè®¡å¡ç‰‡
                    VStack(spacing: 12) {
                        Text("å¯¼å‡ºæ•°æ®é¢„è§ˆ")
                            .font(.headline)

                        HStack {
                            VStack {
                                Text("\(filteredTransactions.count)")
                                    .font(.title2)
                                    .font(.system(size: 18, weight: .bold))
                                    .foregroundColor(.blue)
                                Text("äº¤æ˜“æ•°é‡")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                            .frame(maxWidth: .infinity)

                            Divider()
                                .frame(height: 40)

                            VStack {
                                let totalExpense = filteredTransactions.filter { $0.isExpense }.reduce(0) { $0 + $1.amount }
                                Text("Â¥\(String(format: "%.0f", totalExpense))")
                                    .font(.title2)
                                    .font(.system(size: 18, weight: .bold))
                                    .foregroundColor(.red)
                                Text("æ”¯å‡ºæ€»é‡‘é¢")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                            .frame(maxWidth: .infinity)

                            Divider()
                                .frame(height: 40)

                            VStack {
                                let totalIncome = filteredTransactions.filter { !$0.isExpense }.reduce(0) { $0 + $1.amount }
                                Text("Â¥\(String(format: "%.0f", totalIncome))")
                                    .font(.title2)
                                    .font(.system(size: 18, weight: .bold))
                                    .foregroundColor(.green)
                                Text("æ”¶å…¥æ€»é‡‘é¢")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                            .frame(maxWidth: .infinity)
                        }
                    }
                    .padding()
                    .background(Color(.systemGray6))
                    .cornerRadius(12)

                    // é€‰æ‹©é€‰é¡¹
                    VStack(alignment: .leading, spacing: 16) {
                        Text("å¯¼å‡ºè®¾ç½®")
                            .font(.headline)

                        // æ—¶é—´èŒƒå›´é€‰æ‹©
                        VStack(alignment: .leading, spacing: 8) {
                            Text("æ—¶é—´èŒƒå›´")
                                .font(.subheadline)
                                .font(.system(size: 16, weight: .medium))

                            LazyVGrid(columns: Array(repeating: GridItem(.flexible()), count: 2), spacing: 8) {
                                ForEach(ExportData.DateRange.allCases, id: \.self) { range in
                                    Button(action: { selectedDateRange = range }) {
                                        Text(range.displayName)
                                            .font(.caption)
                                            .padding(.vertical, 8)
                                            .padding(.horizontal, 12)
                                            .frame(maxWidth: .infinity)
                                            .background(selectedDateRange == range ? Color.blue : Color(.systemGray5))
                                            .foregroundColor(selectedDateRange == range ? .white : .primary)
                                            .cornerRadius(8)
                                    }
                                }
                            }
                        }

                        // æ–‡ä»¶æ ¼å¼é€‰æ‹©
                        VStack(alignment: .leading, spacing: 8) {
                            Text("æ–‡ä»¶æ ¼å¼")
                                .font(.subheadline)
                                .font(.system(size: 16, weight: .medium))

                            HStack(spacing: 12) {
                                ForEach(ExportData.ExportFormat.allCases, id: \.self) { format in
                                    Button(action: { selectedFormat = format }) {
                                        HStack {
                                            Image(systemName: selectedFormat == format ? "checkmark.circle.fill" : "circle")
                                            Text(format.displayName)
                                        }
                                        .foregroundColor(selectedFormat == format ? .blue : .primary)
                                    }
                                }
                                Spacer()
                            }
                        }
                    }
                    .padding()
                    .background(Color(.systemGray6))
                    .cornerRadius(12)

                    // æ“ä½œæŒ‰é’®
                    VStack(spacing: 12) {
                        Button(action: previewExportData) {
                            HStack {
                                Image(systemName: "eye")
                                Text("é¢„è§ˆæ•°æ®")
                            }
                            .font(.headline)
                            .foregroundColor(.blue)
                            .padding()
                            .frame(maxWidth: .infinity)
                            .background(Color.blue.opacity(0.1))
                            .cornerRadius(10)
                        }
                        .disabled(filteredTransactions.isEmpty)

                        Button(action: exportData) {
                            HStack {
                                Image(systemName: "square.and.arrow.up")
                                Text("å¯¼å‡ºæ•°æ®")
                            }
                            .font(.headline)
                            .foregroundColor(.white)
                            .padding()
                            .frame(maxWidth: .infinity)
                            .background(filteredTransactions.isEmpty ? Color.gray : Color.green)
                            .cornerRadius(10)
                        }
                        .disabled(filteredTransactions.isEmpty)
                    }

                    if filteredTransactions.isEmpty {
                        VStack(spacing: 8) {
                            Image(systemName: "tray")
                                .font(.largeTitle)
                                .foregroundColor(.secondary)
                            Text("æ‰€é€‰æ—¶é—´èŒƒå›´å†…æ²¡æœ‰æ•°æ®")
                                .foregroundColor(.secondary)
                            Text("è¯·é€‰æ‹©å…¶ä»–æ—¶é—´èŒƒå›´æˆ–å…ˆæ·»åŠ ä¸€äº›äº¤æ˜“è®°å½•")
                                .font(.caption)
                                .foregroundColor(.secondary)
                                .multilineTextAlignment(.center)
                        }
                        .padding(.vertical, 40)
                    }
                }
                .padding()
            }
            .navigationTitle("æ•°æ®å¯¼å‡º")
            .sheet(isPresented: $showingActivityView) {
                if let fileURL = exportedFileURL {
                    ActivityViewController(activityItems: [fileURL])
                }
            }
            .sheet(isPresented: $showingPreview) {
                NavigationView {
                    ScrollView {
                        Text(previewData)
                            .font(.system(.caption, design: .monospaced))
                            .padding()
                    }
                    .navigationTitle("æ•°æ®é¢„è§ˆ")
                    .toolbar {
                        ToolbarItem(placement: .navigationBarTrailing) {
                            Button("å…³é—­") {
                                showingPreview = false
                            }
                        }
                    }
                }
            }
        }
    }

    private func previewExportData() {
        switch selectedFormat {
        case .csv:
            previewData = dataManager.exportDataAsCSV(transactions: filteredTransactions)
        case .txt:
            previewData = dataManager.exportDataAsText(transactions: filteredTransactions)
        }
        showingPreview = true
    }

    private func exportData() {
        let fileName = "VoiceBudget_\(selectedDateRange.rawValue)_\(Date().timeIntervalSince1970).\(selectedFormat.fileExtension)"
        let documentDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!
        let fileURL = documentDirectory.appendingPathComponent(fileName)

        let content: String
        switch selectedFormat {
        case .csv:
            content = dataManager.exportDataAsCSV(transactions: filteredTransactions)
        case .txt:
            content = dataManager.exportDataAsText(transactions: filteredTransactions)
        }

        do {
            try content.write(to: fileURL, atomically: true, encoding: .utf8)
            exportedFileURL = fileURL
            showingActivityView = true
        } catch {
            print("å¯¼å‡ºå¤±è´¥: \(error.localizedDescription)")
        }
    }
}

// MARK: - Activity View Controller
struct ActivityViewController: UIViewControllerRepresentable {
    let activityItems: [Any]

    func makeUIViewController(context: Context) -> UIActivityViewController {
        UIActivityViewController(activityItems: activityItems, applicationActivities: nil)
    }

    func updateUIViewController(_ uiViewController: UIActivityViewController, context: Context) {}
}

// MARK: - Preview
struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
            .environmentObject(DataManager.shared)
    }
}